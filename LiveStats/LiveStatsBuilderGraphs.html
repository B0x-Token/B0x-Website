<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blockchain Data Charts</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.10.0/web3.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
            color: #f2f2f2;
            margin: 0;
            padding: 20px;
        }
        .chart-container {
            margin: 20px 0;
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
        }
        .controls {
            margin-bottom: 20px;
            text-align: center;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #45a049;
        }
        #topText, #topText2 {
            text-align: center;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div id="topText">Loading blockchain data...</div>
    <div id="topText2">This may take a few minutes...</div>
    
    <div class="controls">
        <button onclick="updateGraphData(30, 30)">30 Days</button>
        <button onclick="updateGraphData(60, 60)">60 Days</button>
        <button onclick="updateGraphData(120, 120)">120 Days</button>
    </div>

    <div class="chart-container">
        <h3>Difficulty & Hashrate</h3>
        <div id="difficultystats">Loading...</div>
    </div>

    <div class="chart-container">
        <h3>Block Time & Supply</h3>
        <div id="blocktimestats">Loading...</div>
    </div>

    <div class="chart-container">
        <h3>Price Over Time</h3>
        <div id="priceOverTimestats">Loading...</div>
    </div>

    <div class="chart-container">
        <h3>Average Revenue</h3>
        <div id="avgRevenue">Loading...</div>
    </div>

    <script>
        // Configuration constants
        const _MAXIMUM_TARGET_STR_OLD = "27606985387162255149739023449108101809804435888681546220650096895197184";  // 2**234
        const BWORK_RPC = 'https://base-mainnet.g.alchemy.com/v2/u6woRjFLe5-e3SfnCYFnfoTlgVUangV3';
        const BWORK_CONTRACT_ADDRESS = '0x2f38B1a516239739CdCD2C228D1Eb96E29800975';
        const BWORK_LAST_DIFF_START_BLOCK_INDEX = '4';
        const BWORK_ERA_INDEX = '5';
        const BWORK_TOKENS_MINTED_INDEX = '11';
        const BWORK_MINING_TARGET_INDEX = '6';
        
        const _SECONDS_PER_ETH_BLOCK = 2;
        const _IDEAL_BLOCK_TIME_SECONDS = 600;
        const _HASHRATE_MULTIPLIER = 2**22;
        const _CONTRACT_NAME = 'BWORK';
        
        // These will be initialized after web3 is ready
        let ethblockstart = 30413732;
        let adjustAverageRewardTimeGraph = 8;
        let searchPoints2 = 120;
        let latest_eth_block = null;
        let BWORK_latest_eth_block = null;
        let web3 = null;
        let _ZERO_BN;
        let _MAXIMUM_TARGET_BN_OLD;

        // Helper functions
        function el(selector) {
            return document.querySelector(selector);
        }

        function log(...args) {
            console.log(...args);
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function toReadableThousands(num) {
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'M';
            } else if (num >= 1000) {
                return (num / 1000).toFixed(1) + 'K';
            }
            return num.toString();
        }

        function toReadableThousandsLong(num) {
            return num.toLocaleString();
        }

        function toReadableHashrate(hashrate) {
            if (hashrate >= 1e12) {
                return (hashrate / 1e12).toFixed(2) + ' TH/s';
            } else if (hashrate >= 1e9) {
                return (hashrate / 1e9).toFixed(2) + ' GH/s';
            } else if (hashrate >= 1e6) {
                return (hashrate / 1e6).toFixed(2) + ' MH/s';
            } else if (hashrate >= 1e3) {
                return (hashrate / 1e3).toFixed(2) + ' KH/s';
            }
            return hashrate.toFixed(2) + ' H/s';
        }



        function ethBlockNumberToTimestamp(blockNumber) {
            // Use a more recent reference point for Base network
            // Block 34966000 â‰ˆ December 2024 (adjust this based on current date)
            const referenceBlock = 34966000;
            const referenceTimestamp = Date.now() / 1000; // Current timestamp
            const avgBlockTime = 2; // Base network block time
            
            const blockDifference = blockNumber - referenceBlock;
            const timeDifference = blockDifference * avgBlockTime;
            const blockTimestamp = referenceTimestamp + timeDifference;
            
            return new Date(blockTimestamp * 1000).toLocaleDateString();
        }

        function ethBlockNumberToTimestamp2(blockNumber) {
            const referenceBlock = 34966000;
            const referenceTimestamp = Date.now() / 1000;
            const avgBlockTime = 2;
            
            const blockDifference = blockNumber - referenceBlock;
            const timeDifference = blockDifference * avgBlockTime;
            const blockTimestamp = referenceTimestamp + timeDifference;
            
            return new Date(blockTimestamp * 1000).toLocaleDateString('en-US', {month: 'short', day: 'numeric'});
        }
        function BWORKethBlockNumberToDateStr(blockNumber) {
            return ethBlockNumberToTimestamp2(blockNumber);
        }

        function goToURLAnchor() {
            // Placeholder function
        }

        // Initialize Web3 connection
        async function initEth() {
            try {
                    web3 = new Web3(new Web3.providers.HttpProvider(BWORK_RPC));
                
                
                // Initialize BigNumber constants after web3 is ready
                _ZERO_BN = new web3.utils.BN(0);
                _MAXIMUM_TARGET_BN_OLD = new web3.utils.BN(_MAXIMUM_TARGET_STR_OLD, 10);
                
                // Get latest block
                const latestBlock = await web3.eth.getBlockNumber();
                BWORK_latest_eth_block = latestBlock;
                latest_eth_block = BWORK_latest_eth_block;
                
                log('Connected to Ethereum. Latest block:', BWORK_latest_eth_block);
            } catch (error) {
                console.error('Failed to connect to Ethereum:', error);
                // Initialize fallback values
                web3 = new Web3(new Web3.providers.HttpProvider(BWORK_RPC));
                _ZERO_BN = new web3.utils.BN(0);
                _MAXIMUM_TARGET_BN_OLD = new web3.utils.BN(_MAXIMUM_TARGET_STR_OLD, 10);
                // Use a fallback block number if connection fails
                BWORK_latest_eth_block = 21000000; // Approximate current block
                latest_eth_block = BWORK_latest_eth_block;
            }
        }

        class contractValueOverTime {
          constructor(web3Instance, contract_address, storage_index, descriptor) {
            this.WAIT_DELAY_FIXED_MS = 120;
            this.WAIT_DELAY_ON_TIMEOUT_MS = 1500;
            this.web3 = web3Instance;
            this.contract_address = contract_address;
            this.storage_index = storage_index;
            this.descriptor = descriptor;
            this.sorted = false;
            this.states = [];
            this.expected_state_length = 0;
          }
          
          get getValues() {
            return this.states;
          }
          
          printValuesToLog() {
            this.states.forEach((value) => {
              log('block #', value[0], 'ts', value[2], 'value[1]:', (value[1]).toString(10));
            });
          }
          
          async addValuesInRange(start_block_num, end_block_num, query_count) {
            var stepsize = Math.floor((end_block_num-start_block_num) / query_count);
            log('stepsize', stepsize);
            log('query_count', query_count);

            var storage_data = JSON.parse(localStorage.getItem(this.descriptor));

            var last_storage_block = null;   
            if (storage_data != null) {
              log('read in', storage_data.length, 'cached elements for', this.descriptor);
              last_storage_block = storage_data[storage_data.length - 1][0];
             log("LAST BLOCK: ", last_storage_block, " for ", this.descriptor);
            }

            this.addValueAtEthBlock(end_block_num);

            var d = new Date();
            var secondsSinceMidnight = (d.getTime() - d.setHours(0,0,0,0)) / 1000;
            var blocksSinceMidnight = Math.floor(secondsSinceMidnight / _SECONDS_PER_ETH_BLOCK);
            end_block_num -= blocksSinceMidnight;

            var use_storage = false;
            for (var count = 0; count < query_count - 1; count += 1) {
              var block_num = end_block_num - (stepsize*count);
              if (Math.abs(block_num - last_storage_block) < 2000) {
                use_storage = true;
              }
              if (use_storage) {
                let element = storage_data.pop();
                  if (element && element[0] !== undefined) {
                        try {
                          // Use BigInt for cached data to avoid BN parsing issues
                          let cachedValue;
                          if (typeof element[1] === 'string' && element[1].length > 0) {
                            // Convert cached hex string to BigInt, then to BN
                            let bigIntValue = BigInt('0x' + element[1]);
                            cachedValue = new web3.utils.BN(bigIntValue.toString(), 10);
                          } else {
                            cachedValue = new web3.utils.BN(element[1].toString(), 10);
                          }
                          this.states.push([element[0], cachedValue, '']);
                          this.expected_state_length++;
                        } catch (error) {
                          console.error('Error loading cached data:', error, 'Element:', element);
                          this.addValueAtEthBlock(block_num);
                        }
                    } else {
                        console.error('element is undefined or does not contain the expected properties:', element,"  Block_num: ",block_num );
                        this.addValueAtEthBlock(block_num);
                    }

              } else { 
            log('block_num before addValueAtEthBlock', block_num);
                this.addValueAtEthBlock(block_num);
                await sleep(this.WAIT_DELAY_FIXED_MS);
              }
            }
          }

          _getSaveStateFunction(block_states, eth_block_num, retry_delay) {
            let cv_obj = this;
            console.log("IS?23 : ",eth_block_num)
            if(retry_delay == null) {
              retry_delay = cv_obj.WAIT_DELAY_ON_TIMEOUT_MS;
            }

            return async function (value) {
              if (value == '0x' || value == null) {
                log('cv_obj', cv_obj.storage_index.padStart(2), 'block', eth_block_num, ': got a bad value (', value, '), retrying in ', retry_delay, 'ms...');
                await sleep(retry_delay);
                cv_obj.addValueAtEthBlock(eth_block_num, true, retry_delay*2);
                return;
              } else {
                console.log("FINDZKEEPERZ: ",value);
                
                if (!value || value.length < 3) {
                  console.error('Invalid hex value received:', value);
                  return;
                }
                
                var hex_str = value.substr(2, 64);
                hex_str = hex_str.replace(/[^0-9a-fA-F]/g, '');
                if (hex_str.length === 0) {
                  console.error('No valid hex characters found in:', value);
                  return;
                }
                hex_str = hex_str.padStart(64, '0');
                
                try {
                  if (cv_obj.storage_index.slice(0, 2) == '0x' && cv_obj.storage_index == '0xd66bf39be2869094cf8d2d31edffab51dc8326eadf3c7611d397d156993996da') {
                      var slicedHexStr = hex_str.slice(-40);
                      console.log("SlicedHExStr: ",slicedHexStr);
                      
                      var sqrtPriceX96 = BigInt('0x' + slicedHexStr);
                      console.log("Extracted sqrtPriceX96:", sqrtPriceX96.toString());
                      
                      var Q96 = BigInt('79228162514264337593543950336'); // 2^96
                      var price = (sqrtPriceX96 * sqrtPriceX96) / (Q96 * Q96);
                      
                      console.log("Final Price = ", price.toString());
                      
                      var value_bn = new web3.utils.BN(price.toString(), 10);
                      var len = block_states.push([eth_block_num, value_bn, '']);
                      
                  }else if(cv_obj.storage_index.slice(0, 2) == '0x'){
                      var slicedHexStr = hex_str.slice(-40);
                      console.log("SlicedHExStr: ",slicedHexStr);
                      
                      var sqrtPriceX96 = BigInt('0x' + slicedHexStr);
                      console.log("Extracted sqrtPriceX96:", sqrtPriceX96.toString());
                      
                      var temp = Number(sqrtPriceX96) / (2**96);
                      console.log("sqrtPriceX96/2**96 = ", temp);
                      var final_price = Math.floor(((temp ** 2) * 10**12));
                      console.log("Final Price = ", final_price);

                      var value_bn = new web3.utils.BN(final_price.toString(), 10);
                      var len = block_states.push([eth_block_num, value_bn, '']);
                      
                  }else{
                      console.log("Processing regular storage slot, hex_str:", hex_str);
                      var bigIntValue = BigInt('0x' + hex_str);
                      console.log("BigInt value:", bigIntValue.toString());
                      var value_bn = new web3.utils.BN(bigIntValue.toString(), 10);
                      var len = block_states.push([eth_block_num, value_bn, '']);
                  }
                } catch (error) {
                  console.error('Error creating BigNumber from hex:', hex_str, 'Error:', error);
                  return;
                }
              }
            }
          }
          
          addValueAtEthBlock(eth_block_num, is_retry, retry_delay=600) {
            if(eth_block_num < ethblockstart){
                log('eth_block_num' + eth_block_num);
                return;
            }
            
            let cv_obj = this;
            if(is_retry == null) {
              this.expected_state_length += 1;
            }
            if(retry_delay == null) {
              retry_delay = this.WAIT_DELAY_ON_TIMEOUT_MS;
            }

            eth_block_num = Math.round(eth_block_num)
            console.log("IS? : ",eth_block_num)
            
            try {
              let storageSlot;
              
              console.log('Processing storage index:', this.storage_index, 'Type:', typeof this.storage_index);
              
              if (this.storage_index.slice(0, 2) == '0x') {
                let hexValue = this.storage_index;
                console.log('Using hex storage slot directly:', hexValue);
                
                if (hexValue.length > 10) {
                  storageSlot = hexValue;
                } else {
                  let cleanHex = hexValue.slice(2);
                  if (!/^[0-9a-fA-F]*$/.test(cleanHex)) {
                    throw new Error('Invalid hex characters in storage index: ' + this.storage_index);
                  }
                  storageSlot = '0x' + new web3.utils.BN(cleanHex, 16).toString(16);
                }
              } else {
                console.log('Processing as decimal:', this.storage_index);
                if (!/^\d+$/.test(this.storage_index)) {
                  throw new Error('Invalid decimal characters in storage index: ' + this.storage_index);
                }
                console.log('Creating BN from decimal:', this.storage_index);
                storageSlot = '0x' + new web3.utils.BN(this.storage_index, 10).toString(16);
              }
              
              console.log('Final storage slot:', storageSlot);
              
              this.web3.eth.getStorageAt(
                  this.contract_address, 
                  storageSlot,
                  eth_block_num
              )
              .then(
                this._getSaveStateFunction(this.states, eth_block_num, retry_delay)
              ).catch(async (error) => {
                if(error.message && error.message.substr(error.message.length-4) == 'null') {
                  log('got null from provider, retrying...');
                } else {
                  log('error reading block storage:', error);
                }
                await sleep(retry_delay);
                cv_obj.addValueAtEthBlock(eth_block_num, true, retry_delay*2);
                return;
              });
              
            } catch (error) {
              console.error('Error in addValueAtEthBlock:', error);
              console.error('Storage index:', this.storage_index);
              console.error('Block number:', eth_block_num);
              return;
            }
          }

          areAllValuesLoaded() {
              log("Expected: ",this.expected_state_length ," vs cur Length: ", this.states.length);
              log("searchPoints2: ", searchPoints2);
            return this.expected_state_length == this.states.length;
          }
          
          async waitUntilLoaded() {
            while (!this.areAllValuesLoaded()) {
              await sleep(500);
            }
          }
          
          sortValues() {
            log('sorting values..');
            this.states.sort((a, b) => {
              return a[0] - b[0];
            });
            this.sorted = true;
          }
          
          saveToLocalStorage() {
            localStorage.setItem(this.descriptor, JSON.stringify(this.states.slice(0, -1)));
          }
        }

        function generateHashrateAndBlocktimeGraph(web3Instance, target_cv_obj, era_cv_obj, price_cv_obj, price_cv_obj3, tokens_minted_cv_obj) {
          el('#difficultystats').innerHTML = '<canvas id="chart-hashrate-difficulty" width="4rem" height="2rem"></canvas>';
          el('#blocktimestats').innerHTML =  '<canvas id="chart-rewardtime" width="4rem" height="2rem"></canvas>';
          el('#priceOverTimestats').innerHTML =  '<canvas id="chart-pricetime" width="4rem" height="2rem"></canvas>';
          el('#avgRevenue').innerHTML =  '<canvas id="chart-AvgRevenue" width="4rem" height="2rem"></canvas>';

          var target_values = target_cv_obj.getValues;
          var era_values = era_cv_obj.getValues;
          var tokens_minted_values = tokens_minted_cv_obj.getValues;
          var tokens_price_values = price_cv_obj.getValues;
          var tokens_price_values3 = price_cv_obj3.getValues;

          function convertValuesToChartData(values, value_mod_function) {
            var chart_data = []
            for (var i = 0; i < values.length; i++) {
              if(values[i][1].isZero && values[i][1].isZero()) {
                continue;
              }
              if(value_mod_function == undefined) {
                value_mod_function = function(v){return v};
              }
            if(values[i][0] > ethblockstart){
              chart_data.push({
                x: values[i][0],
                y: value_mod_function(values[i][1]),
              })
            }    
            }
            return chart_data;
          }

          function getErasPerBlockFromEraData(era_values) {
            var chart_data = []
            for (var step = 1; step < era_values.length; step++) {
              var eth_blocks_passed = era_values[step][0] - era_values[step-1][0];
              var eras_passed = era_values[step][1] - era_values[step-1][1];

              if (eth_blocks_passed == 0) {
                continue;
              }

              var eras_per_eth_block = eras_passed / eth_blocks_passed * 7;

              chart_data.push({
                x: era_values[step][0],
                y: eras_per_eth_block,
              })
            }
            return chart_data;
          }

          var difficulty_data = convertValuesToChartData(target_values, 
                                                         (x)=>{return _MAXIMUM_TARGET_BN_OLD.div(x)});
          
          Chart.defaults.global.defaultFontColor = '#f2f2f2';

          var era_data = convertValuesToChartData(era_values);
          var total_supply_data = convertValuesToChartData(tokens_minted_values, 
                                                           (x)=>{return x * 1 / 10**18});
          var total_price_data = convertValuesToChartData(tokens_price_values, 
                                                           (x)=>{return 1 / x });
          var total_price_data3 = convertValuesToChartData(tokens_price_values3, 
                                                           (x)=>{return x });

          const scaleFactor = 10000000;
          let resultGraph = total_price_data.map((item, index) => {
            if (total_price_data[index].y === 0) {
              console.error("Division by zero at index " + index);
              return null;
            }
            return {
              x: item.x,
              y:(item.y)*scaleFactor
            };
          });

          let result2 = total_price_data.map((item, index) => {
            if (total_price_data[index].y === 0) {
              console.error("Division by zero at index " + index);
              return null;
            }
            return {
              x: item.x,
              y: item.y
            };
          });

          let avgPriceAtTime = total_price_data3.map((item, index) => {
            if (result2[index] && result2[index].y !== 0) {
              return {
                x: item.x,
                y: item.y * result2[index].y
              };
            }
            return null;
          }).filter(item => item !== null);

          var eras_per_block_data = getErasPerBlockFromEraData(era_values);
          var average_reward_time_data = [];
          for(var i = 0; i < eras_per_block_data.length; i += 1) {
            if(eras_per_block_data[i].x > ethblockstart){
              average_reward_time_data.push({
                x: eras_per_block_data[i].x,
                y: 1 / (eras_per_block_data[i].y * adjustAverageRewardTimeGraph),
              })
            }
          }

          var datasetCopy = [
            average_reward_time_data.slice(0, 1)[0], 
            average_reward_time_data.slice(average_reward_time_data.length-1, average_reward_time_data.length)[0],
          ]
          if (datasetCopy[0]) {
            datasetCopy[0] = Object.assign({}, datasetCopy[0]);
            datasetCopy[1] = Object.assign({}, datasetCopy[1]);
            datasetCopy[0].y = _IDEAL_BLOCK_TIME_SECONDS / 60;
            datasetCopy[1].y = _IDEAL_BLOCK_TIME_SECONDS / 60;
          }

          // Calculate revenue data
          let avgRevenue = [];
          if (avgPriceAtTime.length > 0 && difficulty_data.length > 0) {
            for (let i = 0; i < Math.min(avgPriceAtTime.length, difficulty_data.length); i++) {
              if (avgPriceAtTime[i] && difficulty_data[i] && difficulty_data[i].y) {
                let difficultyValue = typeof difficulty_data[i].y.toNumber === 'function' 
                  ? difficulty_data[i].y.toNumber() 
                  : difficulty_data[i].y;
                
                let revenue = (31000000000 * 4320000 * 8 / (10 * difficultyValue * 2**22)) * avgPriceAtTime[i].y;
                avgRevenue.push({
                  x: difficulty_data[i].x,
                  y: revenue
                });
              }
            }
          }

          // Create Difficulty Chart
          var hr_diff_chart = new Chart.Scatter(document.getElementById('chart-hashrate-difficulty').getContext('2d'), {
            type: 'line',
            data: {
                datasets: [{
                    label: "Difficulty",
                    showLine: true,
                    steppedLine: 'before',
                    backgroundColor: 'rgb(255, 99, 132)',
                    borderColor: 'rgb(255, 99, 132)',
                    data: difficulty_data,
                    fill: false,
                }]
            },
            options: { 
                responsive: true,
                maintainAspectRatio: true,
                scales: {
                    xAxes: [{
                        gridLines: {
                            color: 'rgb(97, 97, 97)',
                            zeroLineColor: 'rgb(97, 97, 97)',
                        },
                        ticks: {
                            callback: function(value, index, values) {
                                return BWORKethBlockNumberToDateStr(value);
                            },
                        }
                    }],
                    yAxes: [{
                        gridLines: {
                            color: 'rgb(97, 97, 97)',
                            zeroLineColor: 'rgb(97, 97, 97)',
                        },
                        scaleLabel: {
                            display: true,
                            labelString: 'Difficulty',
                            fontColor: 'rgb(255, 99, 132)',
                        },
                        ticks: {
                            callback: function(value, index, values) {
                                return toReadableThousandsLong(value);
                            },
                        }
                    }]
                }
            }
          });

          // Create Price Chart
          var price_chart = new Chart.Scatter(document.getElementById('chart-pricetime').getContext('2d'), {
            type: 'line',
            data: {
                datasets: [{
                    label: "USD Price of 1 BWORK",
                    showLine: true,
                    backgroundColor: 'rgb(50,205,50)',
                    borderColor: 'rgb(50,205,50)',
                    data: avgPriceAtTime,
                    fill: false,
                    yAxisID: 'first-y-axis'
                },{
                    label: "ETH Price of 1 BWORK",
                    showLine: true,
                    backgroundColor: 'rgb(158, 168, 219)',
                    borderColor: 'rgb(158, 168, 219)',
                    data: resultGraph,
                    fill: false,
                    yAxisID: 'second-y-axis'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                scales: {
                    xAxes: [{
                        gridLines: {
                            color: 'rgb(97, 97, 97)',
                            zeroLineColor: 'rgb(97, 97, 97)',
                        },
                        ticks: {
                            callback: function(value, index, values) {
                                return BWORKethBlockNumberToDateStr(value);
                            },
                        }
                    }],
                    yAxes: [{
                        id: 'first-y-axis',
                        position: 'left',
                        gridLines: {
                            color: 'rgb(97, 97, 97)',
                            zeroLineColor: 'rgb(97, 97, 97)',
                        },
                        scaleLabel: {
                            display: true,
                            labelString: 'USD Price',
                            fontColor: 'rgb(50,205,50)',
                        },
                        ticks: {
                            callback: function(value, index, values) {
                                return '$' + value.toFixed(4);
                            },
                        }
                    }, {
                        id: 'second-y-axis',
                        position: 'right',
                        scaleLabel: {
                            display: true,
                            labelString: 'ETH Price',
                            fontColor: 'rgb(158, 168, 219)',
                        },
                        gridLines: {
                            color: 'rgb(97, 97, 97)',
                            zeroLineColor: 'rgb(97, 97, 97)',
                            drawOnChartArea: false,
                        },
                        ticks: {
                            callback: function(value, index, values) {
                                return (value / scaleFactor).toFixed(8) + ' ETH';
                            },
                        }
                    }]
                }
            }
          });

          // Create Block Time & Supply Chart
          var rewardtime_chart = new Chart.Scatter(document.getElementById('chart-rewardtime').getContext('2d'), {
            type: 'line',
            data: {
                datasets: [{
                    label: "Average Reward Time",
                    showLine: true,
                    backgroundColor: 'rgb(79, 195, 247)',
                    borderColor: 'rgb(79, 195, 247)',
                    data: average_reward_time_data,
                    fill: false,
                    yAxisID: 'first-y-axis'
                }, {
                    label: 'Target Reward Time',
                    showLine: true,
                    fill: false,
                    backgroundColor: 'rgb(0, 255, 0)',
                    borderColor: 'rgb(0, 255, 0)',
                    borderDash: [5, 15],
                    pointRadius: 0,
                    data: datasetCopy,
                    yAxisID: 'first-y-axis',
                },{
                    label: "Total Supply",
                    showLine: true,
                    backgroundColor: 'rgb(255, 152, 0)',
                    borderColor: 'rgb(255, 152, 0)',
                    data: total_supply_data,
                    fill: false,
                    yAxisID: 'second-y-axis'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                scales: {
                    xAxes: [{
                        gridLines: {
                            color: 'rgb(97, 97, 97)',
                            zeroLineColor: 'rgb(97, 97, 97)',
                        },
                        ticks: {
                            callback: function(value, index, values) {
                                return BWORKethBlockNumberToDateStr(value);
                            },
                        }
                    }],
                    yAxes: [{
                        id: 'first-y-axis',
                        position: 'left',
                        gridLines: {
                            color: 'rgb(97, 97, 97)',
                            zeroLineColor: 'rgb(97, 97, 97)',
                        },
                        scaleLabel: {
                            display: true,
                            labelString: 'Reward Time (Minutes)',
                            fontColor: 'rgb(79, 195, 247)',
                        },
                        ticks: {
                            callback: function(value, index, values) {
                                return value.toFixed(1) + ' min';
                            },
                        }
                    }, {
                        id: 'second-y-axis',
                        position: 'right',
                        scaleLabel: {
                            display: true,
                            labelString: 'Total Supply (BWORK)',
                            fontColor: 'rgb(255, 152, 0)',
                        },
                        gridLines: {
                            color: 'rgb(97, 97, 97)',
                            zeroLineColor: 'rgb(97, 97, 97)',
                            drawOnChartArea: false,
                        },
                        ticks: {
                            callback: function(value, index, values) {
                                return toReadableThousands(value);
                            },
                        }
                    }]
                }
            }
          });

          // Create Average Revenue Chart
          var revenue_chart = new Chart.Scatter(document.getElementById('chart-AvgRevenue').getContext('2d'), {
            type: 'line',
            data: {
                datasets: [{
                    label: "24 Hour Revenue @ 31 Gh/s",
                    showLine: true,
                    backgroundColor: 'rgb(50,205,50)',
                    borderColor: 'rgb(50,205,50)',
                    data: avgRevenue,
                    fill: false,
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                scales: {
                    xAxes: [{
                        gridLines: {
                            color: 'rgb(97, 97, 97)',
                            zeroLineColor: 'rgb(97, 97, 97)',
                        },
                        ticks: {
                            callback: function(value, index, values) {
                                return BWORKethBlockNumberToDateStr(value);
                            },
                        }
                    }],
                    yAxes: [{
                        gridLines: {
                            color: 'rgb(97, 97, 97)',
                            zeroLineColor: 'rgb(97, 97, 97)',
                        },
                        scaleLabel: {
                            display: true,
                            labelString: 'Daily Revenue (USD)',
                            fontColor: 'rgb(50,205,50)',
                        },
                            ticks: {
                            callback: function(value, index, values) {
                                return '$' + value.toFixed(4);
                            },
                        }
                    }]
                }
            }
          });

          goToURLAnchor(); 
        }

        async function show_progress(value){
          log('updating progress.. (', value, ')');
          el('#difficultystats').innerHTML = '<div class="">Loading info from the blockchain... <span style="font-weight:600;">' + value + '</span></div>';
          el('#blocktimestats').innerHTML = '<div class="">Loading info from the blockchain... <span style="font-weight:600;">' + value + '</span></div>';
          el('#priceOverTimestats').innerHTML = '<div class="">Loading info from the blockchain... <span style="font-weight:600;">' + value + '</span></div>';
          el('#avgRevenue').innerHTML = '<div class="">Loading info from the blockchain... <span style="font-weight:600;">' + value + '</span></div>';
        }

        async function updateHashrateAndBlocktimeGraph(web3Instance, start_eth_block, end_eth_block, num_search_points){
          console.log("123123Start search at: ",start_eth_block);
          console.log("123123end_eth_block: ",end_eth_block);
          
          // Create contract value trackers
          var last_diff_start_blocks = new contractValueOverTime(web3Instance, BWORK_CONTRACT_ADDRESS, BWORK_LAST_DIFF_START_BLOCK_INDEX, 'diffStartBlocks2');
          var era_values = new contractValueOverTime(web3Instance, BWORK_CONTRACT_ADDRESS, BWORK_ERA_INDEX, 'eraValues2');
          var tokens_minted_values = new contractValueOverTime(web3Instance, BWORK_CONTRACT_ADDRESS, BWORK_TOKENS_MINTED_INDEX, 'tokensMinted2');
          var tokens_price_values = new contractValueOverTime(web3Instance, '0x498581fF718922c3f8e6A244956aF099B2652b2b', '0xd66bf39be2869094cf8d2d31edffab51dc8326eadf3c7611d397d156993996da', 'BWORKETHPrice');
          var tokens_price_values3 = new contractValueOverTime(web3Instance, '0x498581fF718922c3f8e6A244956aF099B2652b2b', '0xe570f6e770bf85faa3d1dbee2fa168b56036a048a7939edbcd02d7ebddf3f948', 'USDCETHPrice');
          var mining_target_values = new contractValueOverTime(web3Instance, BWORK_CONTRACT_ADDRESS, BWORK_MINING_TARGET_INDEX, 'miningTargets2');

          // Load data with progress updates
          await tokens_price_values.addValuesInRange(start_eth_block, end_eth_block, num_search_points);
          await sleep(500);
          show_progress('10% [42 / 420]');

          await tokens_price_values3.addValuesInRange(start_eth_block, end_eth_block, num_search_points);
          await sleep(200);
          show_progress('20% [84 / 420]');

          await last_diff_start_blocks.addValuesInRange(start_eth_block, end_eth_block, num_search_points);
          await sleep(200);

          // Wait for completion with progress tracking
          while (!last_diff_start_blocks.areAllValuesLoaded() || !tokens_price_values.areAllValuesLoaded() || !tokens_price_values3.areAllValuesLoaded()) {
              let numerator = tokens_price_values.states.length + tokens_price_values3.states.length + last_diff_start_blocks.states.length;
              let denominator = tokens_price_values.expected_state_length + tokens_price_values3.expected_state_length + last_diff_start_blocks.expected_state_length;
              show_progress((50 * (numerator / denominator)).toFixed(0) + '% [' + (0.5 * numerator).toFixed(0) + ' / ' + denominator.toFixed(0) + ']');
              await sleep(1000);
          }

          await sleep(3000);

          await era_values.addValuesInRange(start_eth_block, end_eth_block, num_search_points);
          await sleep(500);
          show_progress('60% [250 / 420]');

          await tokens_minted_values.addValuesInRange(start_eth_block, end_eth_block, num_search_points);
          await sleep(500);
          show_progress('70% [350 / 420]');

          await mining_target_values.addValuesInRange(start_eth_block, end_eth_block, num_search_points);

          // Wait for all to complete
          await last_diff_start_blocks.waitUntilLoaded();
          await mining_target_values.waitUntilLoaded();
          await tokens_minted_values.waitUntilLoaded();
          await era_values.waitUntilLoaded();
          await tokens_price_values3.waitUntilLoaded();
          await tokens_price_values.waitUntilLoaded();

          // Sort and save data
          last_diff_start_blocks.sortValues();
          mining_target_values.sortValues();
          era_values.sortValues();
          tokens_minted_values.sortValues();
          tokens_price_values.sortValues();
          tokens_price_values3.sortValues();

          generateHashrateAndBlocktimeGraph(web3Instance, mining_target_values, era_values, tokens_price_values, tokens_price_values3, tokens_minted_values);
          
          document.getElementById('topText').style.display = 'none';
          document.getElementById('topText2').style.display = 'none';
          
          // Save to localStorage
          era_values.saveToLocalStorage();
          last_diff_start_blocks.saveToLocalStorage();
          tokens_minted_values.saveToLocalStorage();
          tokens_price_values.saveToLocalStorage();
          tokens_price_values3.saveToLocalStorage();
        }

        function updateGraphData(history_days, num_search_points) {
          show_progress('0% [0 / 0]');

          setTimeout(async ()=>{
            while(BWORK_latest_eth_block == null) {
              log('waiting for BWORK_latest_eth_block...');
              await sleep(300);
            }

            const eth_blocks_per_day = 24*60*(60/_SECONDS_PER_ETH_BLOCK);
            log("_SECONDS_PER_ETH_BLOCK..."+eth_blocks_per_day);
          
            let max_blocks = history_days*eth_blocks_per_day;
            if (max_blocks / num_search_points > eth_blocks_per_day) {
              log("WARNING: search points are greater than 1 day apart. Make sure you know what you are doing...");
            }

            num_search_points = history_days;   
            searchPoints2 = num_search_points
            let start_eth_block = (BWORK_latest_eth_block-max_blocks);
            if(start_eth_block < 30413732){
                start_eth_block = 30413732;
            }
              
            log("latest_eth_block..."+latest_eth_block);
            log("BWORK_latest_eth_block..."+BWORK_latest_eth_block);
            log("USING BWORK_LATEST_ETH_BLOCK RIGHT NOW BWORK_latest_eth_block..."+BWORK_latest_eth_block);
            log("latest_eth_block max_blocks..."+max_blocks);
            log("latest_eth_block...="+(latest_eth_block-max_blocks));
            log("latest_eth_block max_blocks..."+start_eth_block);
            let end_eth_block = BWORK_latest_eth_block-8;

            console.log("zz123123Start search at: ",start_eth_block);
            console.log("zz123123end_eth_block: ",end_eth_block);
            updateHashrateAndBlocktimeGraph(web3, start_eth_block, end_eth_block, num_search_points);

          }, 0); 
        }

        // Initialize when page loads
        window.addEventListener('load', async () => {
            await initEth();
            // Automatically load 30 days of data
            updateGraphData(30, 30);
        });
    </script>
</body>
</html>
