<!DOCTYPE html>
<html lang="en">
<head>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>



    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeFi Operations</title>
     <style>
       
	   /*B0x Widget CSS*/
         .b0x-widget {
            position: fixed;
            top: 20px;
            right: 20px;
            display: inline-flex;
            align-items: center;
            gap: 12px;
            background: rgba(26, 26, 46, 0.95);
            border: 1px solid rgba(15, 52, 96, 0.6);
            border-radius: 8px;
            padding: 8px 14px;
            font-family: 'Arial', sans-serif;
            font-size: 11px;
            color: #ffffff;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            z-index: 1000;
            height: 36px;
            min-width: 280px;
        }

        .b0x-widget:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 24px rgba(15, 52, 96, 0.4);
            border-color: #0ea5e9;
            background: rgba(26, 26, 46, 0.98);
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 6px;
            min-width: 65px;
        }

        .stat-icon {
            width: 14px;
            height: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .stat-value {
            font-weight: 600;
            color: #60a5fa;
            font-size: 11px;
            line-height: 1.2;
        }

        .stat-label {
            color: #94a3b8;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            line-height: 1;
        }

        /* Icons using CSS */
        .icon-dollar::before {
            content: "ðŸ’µ";
            font-size: 12px;
        }

        .icon-btc::before {
            content: "â‚¿";
            font-size: 12px;
            color: #f7931a;
        }

    .icon-0xbtc {
            position: relative;
            width: 16px;
            height: 16px;
            background: #ff7b00;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon-0xbtc::before {
            content: "";
            width: 6px;
            height: 10px;
            background: white;
            clip-path: polygon(0% 20%, 100% 0%, 100% 80%, 0% 100%);
        }



        .icon-hash::before {
            content: "âš¡";
            font-size: 12px;
            color: #10b981;
        }

        .divider {
            width: 1px;
            height: 24px;
            background: linear-gradient(180deg, transparent, #334155, transparent);
        }

        .loading {
            color: #64748b;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Responsive design */
        @media (max-width: 640px) {
            .b0x-widget {
                gap: 8px;
                padding: 6px 10px;
                font-size: 10px;
                height: 32px;
                min-width: 240px;
                top: 15px;
                right: 15px;
            }
            
            .stat-item {
                min-width: 50px;
                gap: 4px;
            }
            
            .divider {
                height: 20px;
            }

            .stat-value {
                font-size: 10px;
            }

            .stat-label {
                font-size: 8px;
            }
        }

        /* Alternative: Inline banner version */
        .b0x-widget.inline {
            position: static;
            display: inline-flex;
            margin-right: auto;
        }
		/* BZeroX Inspired CSS - Part 1 of 3 */



body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: #0a0a0a;
    background-image: 
        radial-gradient(circle at 25% 25%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
        radial-gradient(circle at 75% 75%, rgba(255, 0, 128, 0.2) 0%, transparent 50%),
        linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
    min-height: 100vh;
    padding: 20px;
    color: #ffffff;
    position: relative;
    overflow-x: hidden;
}

body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grid" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 10 0 L 0 0 0 10" fill="none" stroke="rgba(120,119,198,0.1)" stroke-width="0.5"/></pattern></defs><rect width="100" height="100" fill="url(%23grid)"/></svg>');
    pointer-events: none;
    z-index: -1;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    background: rgba(255, 255, 255, 0.02);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 24px;
    box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    overflow: hidden;
    position: relative;
}

.container::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 1px;
    background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(120, 119, 198, 0.6) 50%, 
        transparent 100%);
}

.header {
    background: linear-gradient(135deg, 
        rgba(120, 119, 198, 0.2) 0%, 
        rgba(255, 0, 128, 0.15) 100%);
    backdrop-filter: blur(10px);
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    color: white;
    padding: 40px 30px;
    text-align: center;
    position: relative;
    overflow: hidden;
}

.header::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: conic-gradient(from 0deg at 50% 50%, 
        transparent 0deg, 
        rgba(120, 119, 198, 0.1) 90deg, 
        transparent 180deg, 
        rgba(255, 0, 128, 0.1) 270deg, 
        transparent 360deg);
    animation: rotate 20s linear infinite;
    z-index: -1;
}

@keyframes rotate {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.header h1 {
    font-size: 3rem;
    font-weight: 800;
    background: linear-gradient(135deg, #ffffff 0%, #7877c6 50%, #ff0080 100%);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 12px;
    letter-spacing: -0.02em;
    text-shadow: 0 0 30px rgba(120, 119, 198, 0.5);
}

.header p {
    color: rgba(255, 255, 255, 0.8);
    font-size: 1.2rem;
    font-weight: 400;
    letter-spacing: 0.01em;
}

.nav-tabs {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(3, 1fr);
    background: rgba(0, 0, 0, 0.2);
    backdrop-filter: blur(10px);
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    gap: 1px;
    position: relative;
}

.nav-tab {
    padding: 20px 15px;
    text-align: center;
    cursor: pointer;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    border: none;
    background: rgba(255, 255, 255, 0.02);
    backdrop-filter: blur(5px);
    font-size: 0.95rem;
    font-weight: 500;
    color: rgba(255, 255, 255, 0.7);
    white-space: nowrap;
    position: relative;
    overflow: hidden;
}

.nav-tab::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(120, 119, 198, 0.2) 50%, 
        transparent 100%);
    transition: left 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

.nav-tab:hover {
    background: rgba(120, 119, 198, 0.1);
    color: #ffffff;
    transform: translateY(-2px);
    box-shadow: 0 4px 20px rgba(120, 119, 198, 0.2);
}

.nav-tab:hover::before {
    left: 100%;
}

.nav-tab.active {
    background: linear-gradient(135deg, 
        rgba(120, 119, 198, 0.3) 0%, 
        rgba(255, 0, 128, 0.2) 100%);
    color: #ffffff;
    border-bottom: 3px solid #7877c6;
    box-shadow: 
        0 4px 20px rgba(120, 119, 198, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
}

@media (max-width: 768px) {
    .nav-tabs {
        grid-template-columns: repeat(2, 1fr);
        grid-template-rows: repeat(5, 1fr);
    }
    
    .header h1 {
        font-size: 2rem;
    }
    
    .header p {
        font-size: 1rem;
    }
}







.address-config .form-group {
    margin-bottom: 28px;
}

.address-config .form-group label {
    display: block;
    margin-bottom: 12px;
    font-weight: 600;
    color: rgba(255, 255, 255, 0.9);
    font-size: 0.95rem;
    letter-spacing: 0.01em;
}

.address-config textarea {
    width: 100%;
    height: 200px; /* Set a fixed height */
    min-height: 200px; /* Minimum height */
    max-height: 400px; /* Maximum height for resizing */
    padding: 20px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    font-family: 'JetBrains Mono', 'Courier New', monospace;
    font-size: 0.9rem;
    line-height: 1.6;
    resize: vertical;
    background: rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(10px);
    color: #ffffff;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    box-sizing: border-box;
}

/* Alternative: Make it fill the available space */
.address-config {
    display: flex;
    flex-direction: column;
    min-height: 300px; /* Set minimum container height */
}

.address-config .form-group {
    flex: 1;
    display: flex;
    flex-direction: column;
}

.address-config textarea {
    flex: 1; /* This will make it take up remaining space */
    min-height: 150px;
}

input[readonly] {
    background: rgba(255, 255, 255, 0.08) !important;
    color: rgba(255, 255, 255, 0.9) !important;
    border: 1px solid rgba(255, 255, 255, 0.15) !important;
    cursor: not-allowed;
    padding: 16px 20px !important;
    border-radius: 12px !important;
    font-size: 1rem !important;
    backdrop-filter: blur(10px) !important;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1) !important;
}

input[readonly]:focus {
    background: rgba(255, 255, 255, 0.12) !important;
    border-color: rgba(120, 119, 198, 0.3) !important;
    box-shadow: 0 0 0 3px rgba(120, 119, 198, 0.1) !important;
    outline: none !important;
}

input[readonly]:hover {
    background: rgba(255, 255, 255, 0.1) !important;
    border-color: rgba(255, 255, 255, 0.2) !important;
}


		/*end first part of css code*/
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		/* BZeroX Inspired CSS - Part 2 of 3 */

.content {
    padding: 40px;
    min-height: 500px;
    background: rgba(0, 0, 0, 0.1);
}

.page {
    display: none;
    animation: fadeInUp 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

.page.active {
    display: block;
}

@keyframes fadeInUp {
    from { 
        opacity: 0; 
        transform: translateY(30px) scale(0.95);
    }
    to { 
        opacity: 1; 
        transform: translateY(0) scale(1);
    }
}

.form-group, .form-group2 {
    margin-bottom: 28px;
    position: relative;
}

.form-group label, .form-group2 label {
    display: block;
    margin-bottom: 12px;
    font-weight: 600;
    color: rgba(255, 255, 255, 0.9);
    font-size: 0.95rem;
    letter-spacing: 0.01em;
}

.form-group input, .form-group select, 
.form-group2 input, .form-group2 select {
    width: 100%;
    padding: 16px 20px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    font-size: 1rem;
    background: rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(10px);
    color: #ffffff;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
}

.form-group input::placeholder, 
.form-group2 input::placeholder {
    color: rgba(255, 255, 255, 0.4);
}

.form-group input:focus, .form-group select:focus,
.form-group2 input:focus, .form-group2 select:focus {
    outline: none;
    border-color: #7877c6;
    background: rgba(120, 119, 198, 0.1);
    box-shadow: 
        0 0 0 3px rgba(120, 119, 198, 0.2),
        0 8px 25px rgba(120, 119, 198, 0.15);
    transform: translateY(-2px);
}

.form-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 24px;
}

.btn-primary, .btn-success, .btn-warning {
    color: white;
    border: none;
    padding: 16px 32px;
    border-radius: 12px;
    font-size: 1.1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    width: 100%;
    margin-top: 24px;
    position: relative;
    overflow: hidden;
    text-transform: none;
    letter-spacing: 0.01em;
}

.btn-primary {
    background: linear-gradient(135deg, #7877c6 0%, #5a4fcf 100%);
    box-shadow: 
        0 8px 25px rgba(120, 119, 198, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
}

.btn-success {
    background: linear-gradient(135deg, #00d4aa 0%, #00b894 100%);
    box-shadow: 
        0 8px 25px rgba(0, 212, 170, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
}

.btn-warning {
    background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
    box-shadow: 
        0 8px 25px rgba(255, 107, 107, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
}

.btn-primary::before, .btn-success::before, .btn-warning::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(255, 255, 255, 0.2) 50%, 
        transparent 100%);
    transition: left 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

.btn-primary:hover, .btn-success:hover, .btn-warning:hover {
    transform: translateY(-4px);
    box-shadow: 
        0 12px 35px rgba(120, 119, 198, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
}

.btn-primary:hover::before, .btn-success:hover::before, .btn-warning:hover::before {
    left: 100%;
}

.btn-row {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 16px;
    margin-top: 24px;
}

.swap-direction {
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 24px 0;
}

.swap-arrow {
    background: linear-gradient(135deg, #7877c6 0%, #5a4fcf 100%);
    color: white;
    border: none;
    border-radius: 50%;
    width: 56px;
    height: 56px;
    font-size: 1.5rem;
    cursor: pointer;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 
        0 8px 25px rgba(120, 119, 198, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    display: flex;
    align-items: center;
    justify-content: center;
}

.swap-arrow:hover {
    transform: rotate(180deg) scale(1.1);
    box-shadow: 
        0 12px 35px rgba(120, 119, 198, 0.6),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
}

.token-selector {
    display: flex;
    align-items: center;
    gap: 12px;
}

.token-icon {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    background: linear-gradient(135deg, #7877c6 0%, #ff0080 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    color: white;
    font-size: 0.9rem;
    box-shadow: 0 4px 15px rgba(120, 119, 198, 0.3);
}

.info-card, .info-card2, .info-card3 {
    background: rgba(255, 255, 255, 0.03);
    backdrop-filter: blur(15px);
    border: 1px solid rgba(120, 119, 198, 0.2);
    border-left: 4px solid #7877c6;
    padding: 24px;
    border-radius: 16px;
    margin-bottom: 24px;
    position: relative;
    overflow: hidden;
}

.info-card::before, .info-card2::before, .info-card3::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(135deg, 
        rgba(120, 119, 198, 0.05) 0%, 
        rgba(255, 0, 128, 0.02) 100%);
    z-index: -1;
}

.info-card h3, .info-card2 h3, .info-card3 h3 {
    color: #7877c6;
    margin-bottom: 12px;
    font-size: 1.3rem;
    font-weight: 700;
}

.info-card p, .info-card2 p, .info-card3 p {
    color: rgba(255, 255, 255, 0.8);
    line-height: 1.6;
}

.rewards-card {
    background: linear-gradient(135deg, 
        rgba(0, 212, 170, 0.2) 0%, 
        rgba(0, 184, 148, 0.3) 100%);
    backdrop-filter: blur(15px);
    border: 1px solid rgba(0, 212, 170, 0.3);
    color: white;
    padding: 32px;
    border-radius: 20px;
    margin-bottom: 32px;
    text-align: center;
    position: relative;
    overflow: hidden;
}

.rewards-card::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: conic-gradient(from 0deg at 50% 50%, 
        transparent 0deg, 
        rgba(0, 212, 170, 0.1) 90deg, 
        transparent 180deg, 
        rgba(0, 184, 148, 0.1) 270deg, 
        transparent 360deg);
    animation: rotate 15s linear infinite;
    z-index: -1;
}

.rewards-card h3 {
    font-size: 1.8rem;
    margin-bottom: 16px;
    font-weight: 700;
}

.rewards-amount {
    font-size: 2.8rem;
    font-weight: 800;
    margin-bottom: 12px;
    background: linear-gradient(135deg, #ffffff 0%, #00d4aa 100%);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}

.rewards-usd {
    font-size: 1.3rem;
    color: rgba(255, 255, 255, 0.8);
    margin-bottom: 24px;
}



.button-group {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    margin-top: 24px;
    align-items: center;
}

.btn-secondary {
    background: rgba(255, 255, 255, 0.08);
    backdrop-filter: blur(10px);
    color: rgba(255, 255, 255, 0.9);
    border: 1px solid rgba(255, 255, 255, 0.15);
    padding: 12px 24px;
    border-radius: 10px;
    font-size: 0.95rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
    white-space: nowrap;
    flex: 0 0 auto;
}

.btn-secondary::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(255, 255, 255, 0.1) 50%, 
        transparent 100%);
    transition: left 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

.btn-secondary:hover {
    background: rgba(255, 255, 255, 0.12);
    border-color: rgba(255, 255, 255, 0.25);
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(255, 255, 255, 0.1);
    color: #ffffff;
}

.btn-secondary:hover::before {
    left: 100%;
}

.btn-secondary:active {
    transform: translateY(0);
}


/*end second part of css code*/
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		/* BZeroX Inspired CSS - Part 3 of 3 */

.staking-stats {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 24px;
    margin-bottom: 32px;
}

.stat-card {
    background: rgba(255, 255, 255, 0.03);
    backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 16px;
    padding: 24px;
    text-align: center;
    position: relative;
    overflow: hidden;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

.stat-card:hover {
    transform: translateY(-4px);
    border-color: rgba(120, 119, 198, 0.3);
    box-shadow: 0 12px 35px rgba(120, 119, 198, 0.2);
}

.stat-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 2px;
    background: linear-gradient(90deg, #7877c6, #ff0080);
    border-radius: 16px 16px 0 0;
}

.stat-value {
    font-size: 2rem;
    font-weight: 800;
    background: linear-gradient(135deg, #7877c6 0%, #ff0080 100%);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 8px;
}

.stat-label {
    color: rgba(255, 255, 255, 0.7);
    font-size: 0.9rem;
    font-weight: 500;
}

.slider-container {
    margin: 24px 0;
    position: relative;
}

.slider {
    width: 100%;
    height: 8px;
    border-radius: 5px;
    background: rgba(255, 255, 255, 0.1);
    outline: none;
    -webkit-appearance: none;
    position: relative;
    overflow: hidden;
}

.slider::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: var(--value, 25%);
    background: linear-gradient(90deg, #7877c6, #ff0080);
    border-radius: 5px;
    transition: width 0.3s ease;
}

.slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background: linear-gradient(135deg, #7877c6 0%, #ff0080 100%);
    cursor: pointer;
    box-shadow: 
        0 4px 15px rgba(120, 119, 198, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.slider::-webkit-slider-thumb:hover {
    transform: scale(1.2);
    box-shadow: 
        0 6px 20px rgba(120, 119, 198, 0.6),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
}

.percentage-display {
    text-align: center;
    font-size: 1.4rem;
    font-weight: 700;
    background: linear-gradient(135deg, #7877c6 0%, #ff0080 100%);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-top: 16px;
}





#connectBtn {
    background: linear-gradient(135deg, #7877c6 0%, #5a4fcf 100%);
    color: white;
    border: none;
    padding: 16px 32px;
    border-radius: 12px;
    font-size: 1.1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 
        0 8px 25px rgba(120, 119, 198, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    position: relative;
    overflow: hidden;
}

#connectBtn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(255, 255, 255, 0.2) 50%, 
        transparent 100%);
    transition: left 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

#connectBtn:hover {
    transform: translateY(-4px);
    box-shadow: 
        0 12px 35px rgba(120, 119, 198, 0.6),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
}

#connectBtn:hover::before {
    left: 100%;
}

#connectBtn.connected {
    background: linear-gradient(135deg, #00d4aa 0%, #00b894 100%);
    box-shadow: 
        0 8px 25px rgba(0, 212, 170, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
}

#connectBtn.connected:hover {
    box-shadow: 
        0 12px 35px rgba(0, 212, 170, 0.6),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
}

#walletInfo button {
    background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
    color: white;
    border: none;
    padding: 12px 20px;
    border-radius: 8px;
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    margin-left: 16px;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
}

#walletInfo button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(255, 107, 107, 0.5);
}


#walletAddress {
    font-size: 1rem;
    font-weight: 700;
    font-family: 'JetBrains Mono', 'Courier New', monospace;
    padding: 0; /* Remove padding from span */
    background: rgba(0, 0, 0, 0.8);
    border-radius: 12px;
    display: inline-block;
    margin-right: 16px;
    box-shadow: 
        0 0 20px rgba(0, 255, 136, 0.5),
        inset 0 1px 0 rgba(0, 255, 136, 0.2);
    border: 1px solid #00ff88;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    overflow: hidden;
}

/* Style the anchor tag inside walletAddress */
#walletAddress a {
    color: #ffffff;
    text-decoration: none;
    display: block;
    padding: 16px 24px; /* Move padding to the link */
    letter-spacing: 0.5px;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

#walletAddress:hover {
    transform: translateY(-3px);
    box-shadow: 
        0 0 30px rgba(0, 255, 136, 0.8),
        0 8px 25px rgba(0, 255, 136, 0.3);
}

#walletAddress a:hover {
    color: #00ff88; /* Optional: change color on hover */
}

/* Ensure the link fills the entire button area */
#walletAddress a:focus {
    outline: none;
}







/* Update the wallet section layout for vertical stacking */
.wallet-section {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 12px; /* Space between connect button and wallet info */
    margin-bottom: 20px;
}


#walletInfo {
    display: flex !important;
    align-items: center;
    gap: 0; /* No gap between address and disconnect button */
}

/* Style disconnect button to match wallet address */
#walletInfo button {
    font-size: 1rem;
    font-weight: 700;
    font-family: 'JetBrains Mono', 'Courier New', monospace;
    padding: 16px 24px; /* Same padding as wallet address */
    background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
    color: white;
    border: 1px solid #ff6b6b;
    border-radius: 12px;
    cursor: pointer;
    margin-left: 0; /* Remove margin */
    margin-right: 0;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 
        0 0 20px rgba(255, 107, 107, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
    display: inline-block;
    vertical-align: top; /* Align to top */
    border-radius: 0 12px 12px 0; /* Round only right side */
}












#walletInfo button:hover {
    transform: translateY(-3px);
    box-shadow: 
        0 0 30px rgba(255, 107, 107, 0.8),
        0 8px 25px rgba(255, 107, 107, 0.3);
    background: linear-gradient(135deg, #ff5252 0%, #d32f2f 100%);
}





/* Sync hover effects - when one is hovered, both move */
#walletInfo:hover #walletAddress,
#walletInfo:hover button {
    transform: translateY(-3px);
}







.wallet-balances {
    margin-bottom: 32px;
}

.wallet-balances h3 {
    font-size: 1.6rem;
    font-weight: 700;
    background: linear-gradient(135deg, #ffffff 0%, #7877c6 100%);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 24px;
    text-align: center;
}

.balances-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
    gap: 20px;
    margin-top: 20px;
}

.balance-item {
    background: rgba(255, 255, 255, 0.03);
    backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 16px;
    padding: 20px;
    display: flex;
    flex-direction: column;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
}

.balance-item:hover {
    transform: translateY(-4px);
    border-color: rgba(120, 119, 198, 0.3);
    box-shadow: 0 12px 35px rgba(120, 119, 198, 0.2);
}

.balance-item::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: linear-gradient(90deg, #7877c6, #ff0080);
    border-radius: 16px 16px 0 0;
}

.token-name {
    font-weight: 600;
    color: rgba(255, 255, 255, 0.8);
    margin-bottom: 12px;
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.token-amount {
    font-size: 1.4rem;
    font-weight: 700;
    background: linear-gradient(135deg, #ffffff 0%, #7877c6 100%);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    word-break: break-all;
}

.loading-text {
    color: rgba(255, 255, 255, 0.6);
    font-style: italic;
    text-align: center;
    padding: 60px 20px;
    font-size: 1.1rem;
}

.spinner {
    display: inline-block;
    width: 20px;
    height: 20px;
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-top: 2px solid #7877c6;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-right: 12px;
}

.toggle-container {
    display: inline-block;
    margin: 16px 0;
}

.toggle-switch {
    position: relative;
    display: inline-block;
    width: 64px;
    height: 36px;
}

.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.toggle-slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255, 255, 255, 0.1);
    transition: 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    border-radius: 36px;
    border: 1px solid rgba(255, 255, 255, 0.2);
}

.toggle-slider:before {
    position: absolute;
    content: "";
    height: 28px;
    width: 28px;
    left: 3px;
    bottom: 3px;
    background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
    transition: 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    border-radius: 50%;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

input:checked + .toggle-slider {
    background: linear-gradient(135deg, #7877c6 0%, #5a4fcf 100%);
    border-color: #7877c6;
}

input:checked + .toggle-slider:before {
    transform: translateX(28px);
    background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
}

.toggle-label {
    margin-left: 16px;
    vertical-align: middle;
    font-size: 1rem;
    color: rgba(255, 255, 255, 0.8);
    font-weight: 500;
}



#loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    color: white;
    font-family: 'Inter', sans-serif;
}

.loading-content {
    text-align: center;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    /* Add max-width and center the entire content block */
    max-width: 500px;
    /* Use transform to perfectly center regardless of content height */
    transform: translateY(-5%); /* Slight adjustment to account for visual center */
}

.loader {
    width: 80px;
    height: 80px;
    border: 4px solid rgba(255, 255, 255, 0.1);
    border-top: 4px solid #7877c6;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 40px;
    /* Ensure the loader stays centered */
    align-self: center;
}

/* Rest of your CSS stays the same */
@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

.loading-title {
    font-size: 3rem;
    font-weight: 800;
    margin-bottom: 16px;
    background: linear-gradient(135deg, #ffffff 0%, #7877c6 100%);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    opacity: 0;
    animation: fadeIn 0.8s ease forwards 0.5s;
}

.loading-subtitle {
    font-size: 1.3rem;
    color: rgba(255, 255, 255, 0.8);
    margin-bottom: 24px;
    opacity: 0;
    animation: fadeIn 0.8s ease forwards 1s;
}

.loading-status {
    font-size: 1.1rem;
    color: rgba(255, 255, 255, 0.6);
    opacity: 0;
    animation: fadeIn 0.8s ease forwards 1.5s;
}




/* Button disabled states */
button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none !important;
    box-shadow: none !important;
}

button:disabled:hover {
    transform: none !important;
    box-shadow: none !important;
}


















/*newnew*/






        .loading-widget {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(26, 26, 46, 0.95);
            border: 1px solid rgba(120, 119, 198, 0.3);
            border-radius: 12px;
            padding: 16px 20px;
            min-width: 280px;
            max-width: 400px;
            z-index: 9999;
            backdrop-filter: blur(10px);
            box-shadow: 
                0 10px 40px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.05) inset;
            transform: translateX(420px);
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            color: white;
            font-family: 'Inter', sans-serif;
        }

        .loading-widget.show {
            transform: translateX(0);
            opacity: 1;
        }

        .loading-widget-header {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }

        .loading-widget-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-top: 2px solid #7877c6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 12px;
        }

        .loading-widget-title {
            font-weight: 600;
            font-size: 14px;
            color: #ffffff;
        }

        .loading-widget-close {
            margin-left: auto;
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 32px;
            font-weight: bold;
            min-width: 64px;
            min-height: 64px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .loading-widget-close:hover {
            color: rgba(255, 255, 255, 1);
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.1);
        }

        .loading-widget-message {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.8);
            line-height: 1.4;
        }

        .loading-widget-progress {
            width: 100%;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            margin-top: 12px;
            overflow: hidden;
        }

        .loading-widget-progress-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #7877c6, #ff0080);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .loading-widget.success {
            border-color: rgba(34, 197, 94, 0.3);
        }

        .loading-widget.success .loading-widget-spinner {
            border-top-color: #22c55e;
        }

        .loading-widget.error {
            border-color: rgba(239, 68, 68, 0.3);
        }

        .loading-widget.error .loading-widget-spinner {
            border-top-color: #ef4444;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }




        /*STATS CSS*/
        /*STATS CSS BEGINS*/


                .logo {
            background: #333;
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            font-weight: bold;
            margin-right: 15px;
            font-size: 14px;
        }

        .title {
            font-size: 24px;
            font-weight: 400;
        }

        .nav-tabs2 {
            display: flex;
            gap: 0px;
            margin-bottom: 40px;
            border-bottom: 1px solid #333;
            padding-bottom: 15px;
        }

        .nav-tab2 {
            background: none;
            border: none;
            color: #888;
            font-size: 14px;
            cursor: pointer;
            padding: 5px 0;
            transition: color 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nav-tab2:hover {
            color: #fff;
        }

        .nav-tab2.active {
            color: #8b5cf6;
        }

        .nav-tab2::before {
            content: '';
            width: 16px;
            height: 16px;
            background-size: contain;
        }

        .nav-tab2[data-tab="stats"]::before {
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" fill="%23888" viewBox="0 0 24 24"><path d="M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v4h8V3h-8z"/></svg>');
        }

        .nav-tab2[data-tab="mining"]::before {
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" fill="%23888" viewBox="0 0 24 24"><path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>');
        }

        .nav-tab2[data-tab="difficulty"]::before {
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" fill="%23888" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>');
        }

        .nav-tab2[data-tab="reward"]::before {
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" fill="%23888" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>');
        }

        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        .section-title {
            font-size: 20px;
            font-weight: 400;
            margin-bottom: 30px;
            color: #fff;
        }

        .stats-grid {
            display: flex;
            flex-direction: column;
            gap: 1px;
            background: #333;
            border-radius: 8px;
            overflow: hidden;
        }

        .stat-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            align-items: center;
            padding: 18px 24px;
            background: #2a2a2a;
            transition: background-color 0.2s;
            gap: 15px;
        }

        .stat-row:hover {
            background: #333;
        }

        .stat-label2 {
            font-size: 25px;
            color: #ccc;
            font-weight: 400;
        }

        .stat-value2 {
            font-size: 23px;
            color: #ffffff;
            font-weight: 600;
            text-align: left;
            line-height: 1.4;
        
        }

        .stat-value2.highlight {
            color: #8b5cf6;
        }

        .stat-value2 .unit {
            color: #c0c0c0;
            font-size: 19px;
            font-weight: 400;
            margin-left: 6px;
        }

        .stat-value2 .detail {
            color: #999;
            font-size: 13px;
            font-weight: 400;
            margin-left: 8px;
        }


        .nav-tabs2 {
            display: flex;
            gap: 8px;
            margin: 20px 0;
            padding: 4px;
            background: #1e1e1e;
            border-radius: 8px;
            border: 1px solid #333;
        }

              .nav-tabs2 {
            display: flex;
            gap: 8px;
            margin: 20px 0;
            padding: 4px;
            background: #1e1e1e;
            border-radius: 8px;
            border: 1px solid #333;
            justify-content: flex-start;
            align-items: center;
        }

        .nav-tabs2 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
            margin: 20px 0;
            padding: 12px;
            background: #1e1e1e;
            border-radius: 12px;
            border: 1px solid #333;
        }

     

        .nav-tabs2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 8px;
            margin: 20px 0;
            padding: 8px;
            background: #1e1e1e;
            border-radius: 12px;
            border: 1px solid #333;
            max-width: 100%;
        }

        .nav-tab2 {
            background: #2a2a2a;
            border: 1px solid #404040;
            color: #b0b0b0;
            font-size: 13px;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 6px;
            transition: all 0.3s ease;
            font-weight: 500;
            position: relative;
            overflow: hidden;
            text-align: center;
            white-space: nowrap;
            text-overflow: ellipsis;
            min-width: 0;
        }

        .nav-tab2:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(139, 92, 246, 0.1), transparent);
            transition: left 0.5s;
        }

        .nav-tab2:hover {
            color: #ffffff;
            background: #363636;
            border-color: #5a5a5a;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .nav-tab2:hover:before {
            left: 100%;
        }

        .nav-tab2.active {
            color: #ffffff;
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            border-color: #8b5cf6;
            box-shadow: 0 4px 16px rgba(139, 92, 246, 0.3);
            font-weight: 600;
        }

        .nav-tab2.active:hover {
            background: linear-gradient(135deg, #7c3aed, #6d28d9);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(139, 92, 246, 0.4);
        }

        .stats-page {
            display: none;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            
            .nav-tabs2 {
                flex-wrap: wrap;
                gap: 00px;
            }
            
            .stat-row {
                padding: 15px 18px;
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
            }
            

            .stat-value2 {
                text-align: left;
                font-size: 15px;
                color: #ffffff;
                font-weight: 600;
                text-align: left;
                line-height: 1.4;
            
            }

        .stat-value2 .unit {
            color: #c0c0c0;
            font-size: 14px;
            font-weight: 400;
            margin-left: 6px;
        }

        .stat-label2 {
            font-size: 16px;
            color: #ccc;
            font-weight: 400;
        }


        }



        /*STATS CSS ENDS*/


        /*Stats Mining Calculator STARTS*/




        /* Mining Calculator Styles */
        /* Mining Calculator Styles */
      
        

        /* Mining Calculator Styles */
        .mining-calculator {
            margin-top: 30px;
        }

        .calculator-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0px;
            margin-bottom: 0px;
        }

        .input-group {
            margin-bottom: 30px;
        }

        .input-label {
            display: block;
            color: #f0f0f0;
            font-size: 15px;
            font-weight: 500;
            margin-bottom: 8px;
        }

        .info-icon {
            color: #8b5cf6;
            cursor: help;
            font-size: 14px;
            margin-left: 4px;
        }

        .input-with-unit {
           
    flex: 0 0 auto; /* Don't grow, don't shrink, use natural size */
            align-items: center;
            gap: 12px;
        }

        .calc-input {
    flex: none;
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 10px 12px;
            color: #fff;
            font-size: 14px;
            min-width: 100px;
        }

        .calc-input:focus {
            outline: none;
            border-color: #8b5cf6;
        }

        .difficulty-input {
            min-width: 200px;
            margin-bottom: 24px;
        }

        .input-unit {
            color: #ccc;
            font-size: 14px;
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        .calc-button {
            background: #444;
            border: 1px solid #666;
            color: #8b5cf6;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .calc-button:hover {
            background: #555;
            border-color: #8b5cf6;
        }

        .calc-button.secondary {
            background: #333;
        }

.results-section {
    background: #2a2a2a;
    padding: 25px;
    border-radius: 8px;
    border: 1px solid #444;
    width: 300px;      /* or any width you want */
    box-sizing: border-box;
    overflow-wrap: break-word;
    word-break: break-word;
    margin: 0;         /* remove offsets */
}

        .results-title {
            color: #f0f0f0;
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 20px;
        }

        .result-item {
            color: #ccc;
            font-size: 14px;
            line-height: 1.6;
            margin-bottom: 8px;
        }

        .result-item span {
            color: #fff;
            font-weight: 600;
        }

        .how-it-works {
            margin-top: 50px;
        }

        .section-subtitle {
            color: #f0f0f0;
            font-size: 18px;
            font-weight: 500;
            margin-bottom: 15px;
        }

        .explanation {
            color: #ccc;
            font-size: 14px;
            margin-bottom: 25px;
        }

        .formula-block {
            background: #2a2a2a;
            border-left: 4px solid #8b5cf6;
            padding: 20px 25px;
            margin: 25px 0;
            font-family: 'Courier New', monospace;
        }

        .formula-line {
            color: #f0f0f0;
            font-size: 13px;
            line-height: 1.8;
            margin-bottom: 8px;
        }

        .formula-fraction {
            color: #8b5cf6;
        }

        .formula-divisor {
            color: #ff6b6b;
        }

        .formula-complex {
            color: #4ecdc4;
        }

        .reference {
            color: #ccc;
            font-size: 14px;
            margin-top: 30px;
            margin-bottom: 10px;
        }

        .reference-list {
            margin: 0;
            padding-left: 20px;
        }

        .reference-list li {
            color: #ccc;
            margin-bottom: 5px;
        }

        .reference-link {
            color: #8b5cf6;
            text-decoration: none;
        }

        .reference-link:hover {
            text-decoration: underline;
        }



        .container {
                padding: 15px;
            }
            


        @media (max-width: 768px) {f
            .container {
                padding: 10px;
            }
            
            
            .nav-tabs2 {
                flex-wrap: wrap;
                gap: 1px;
            }
            
            .stat-row {
                padding: 15px 18px;
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
            }
            
            .calculator-grid {
                grid-template-columns: 1fr;
                gap: 0px;
            }
        }

    /* Main formula container */
        .formula-block {
            background: rgba(255, 255, 255, 0.05);
            border-left: 3px solid #64ffda;
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            line-height: 2;
        }

        /* Individual formula lines */
        .formula-line {
            margin: 15px 0;
            color: #e0e0e0;
            font-size: 16px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }

        /* Fraction container - this wraps the numerator and denominator */
        .fraction {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            margin: 0 4px;
            vertical-align: middle;
        }

        /* Numerator styling */
        .formula-fraction {
            color: #64ffda;
            font-weight: 500;
            padding: 2px 6px;
            text-align: center;
            border-bottom: 2px solid #ffffff;
            margin-bottom: 2px;
            min-width: 80px;
        }

        /* Denominator styling */
        .formula-divisor {
            color: #ff9800;
            font-weight: 500;
            padding: 2px 6px;
            text-align: center;
            margin-top: 2px;
            min-width: 80px;
        }

        /* Complex formula grouping */
        .formula-complex {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            background: rgba(100, 255, 218, 0.1);
            border-radius: 4px;
            border: 1px solid rgba(100, 255, 218, 0.2);
            margin: 0 4px;
        }

        /* Nested fractions within complex formulas */
        .formula-complex .fraction {
            margin: 0 2px;
        }

        .formula-complex .formula-fraction,
        .formula-complex .formula-divisor {
            font-size: 14px;
            padding: 1px 4px;
            min-width: 60px;
        }

        /* Superscript styling */
        sup {
            color: #bb86fc;
            font-size: 0.8em;
            font-weight: bold;
        }

        /* Mathematical operators */
        .operator {
            color: #ffffff;
            font-weight: bold;
            margin: 0 6px;
        }

        /* Arrow styling */
        .arrow {
            color: #64ffda;
            font-weight: bold;
            margin-right: 8px;
        }
        /*STATS Mining Calculator CSS ENDS*/
.parent-container {
    display: flex;
    justify-content: flex-end; /* pushes children to the right */
    align-items: flex-start;   /* aligns them to the top */
    width: 100%;
}



        /*STATS Mining Calculator CSS BEGINSS*/
      .mining-calculator {
            margin-bottom: 40px;
        }

        .calculator-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        /* Control Box Styling */
        .controls-box {
            background: rgba(26, 32, 44, 0.8);
            border-radius: 12px;
            padding: 24px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group:last-child {
            margin-bottom: 0;
        }

        .input-label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 8px;
            color: #cbd5e0;
        }

        /* Hashrate Input with Unit Selector */
        .input-with-unit {
            display: inline-flex;
            width: fit-content;
            align-items: center;
            background: rgba(45, 55, 72, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            overflow: hidden;
            transition: all 0.2s;
        }

        .input-with-unit:focus-within {
            border-color: #805ad5;
            box-shadow: 0 0 0 3px rgba(128, 90, 213, 0.1);
        }

        .calc-input {
            flex: none;
            min-width: 120px;
            padding: 12px 15px;
            background: transparent;
            border: none;
            color: #e2e8f0;
            font-size: 14px;
            outline: none;
            border-radius: 0;
        }

        .calc-input::placeholder {
            color: #718096;
        }

        .unit-selector {
            background: rgba(128, 90, 213, 0.8);
            border: none;
            color: #e2e8f0;
            padding: 12px 15px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
            min-width: 70px;
        }

        .unit-selector:hover {
            background: rgba(128, 90, 213, 1);
        }

        .unit-selector:focus {
            outline: none;
            background: rgba(128, 90, 213, 1);
        }

        /* Regular Input (for difficulty) */
        .difficulty-input {
            width: 100%;
            max-width: 200px;
            padding: 12px 15px;
            background: rgba(45, 55, 72, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #e2e8f0;
            font-size: 23px;
            box-sizing: border-box;
        }

        .difficulty-input:focus {
            outline: none;
            border-color: #805ad5;
            box-shadow: 0 0 0 3px rgba(128, 90, 213, 0.1);
        }

        /* Button Group */
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .calc-button {
            padding: 10px 16px;
            background: rgba(128, 90, 213, 0.8);
            border: 1px solid rgba(128, 90, 213, 0.6);
            border-radius: 6px;
            color: #e2e8f0;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .calc-button:hover {
            background: rgba(128, 90, 213, 1);
            border-color: rgba(128, 90, 213, 0.8);
            transform: translateY(-1px);
        }

        .calc-button.secondary {
            background: rgba(74, 85, 104, 0.8);
            border-color: rgba(74, 85, 104, 0.6);
        }

        .calc-button.secondary:hover {
            background: rgba(74, 85, 104, 1);
            border-color: rgba(74, 85, 104, 0.8);
        }

        /* Results Section */
        .results-section {
            background: rgba(26, 32, 44, 0.9);
            border-radius: 12px;
            padding: 24px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .results-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #f7fafc;
        }

        .result-item {
            margin-bottom: 15px;
            font-size: 23px;
            line-height: 1.5;
        }

        .result-item span {
            font-weight: 600;
            color: #68d391;
        }

        /* Formula Section */
        #stats .how-it-works {
            background: rgba(45, 55, 72, 0.8);
            border-radius: 12px;
            padding: 24px;
            margin-top: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

       #stats .section-subtitle {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #f7fafc;
        }

       #stats .explanation {
            color: #cbd5e0;
            margin-bottom: 20px;
            line-height: 1.6;
        }

       #stats .formula-block {
            background: rgba(26, 32, 44, 0.6);
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
        }

       #stats .formula-line {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }

      #stats .fraction {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            position: relative;
        }

       #stats .formula-fraction {
            border-bottom: 1px solid #cbd5e0;
            padding-bottom: 2px;
            margin-bottom: 2px;
        }

       #stats .formula-divisor {
            padding-top: 2px;
        }

       #stats .arrow {
            color: #68d391;
            font-weight: bold;
            margin: 0 10px;
        }

       #stats .operator {
            color: #68d391;
            font-weight: bold;
            margin: 0 5px;
        }

       #stats .reference {
            color: #cbd5e0;
            margin-top: 20px;
            margin-bottom: 10px;
        }

       #stats .reference-list {
            margin-left: 20px;
        }

        #stats .reference-link {
            color: #68d391;
            text-decoration: none;
        }

       #stats .reference-link:hover {
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            #stats .calculator-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
           #stats .button-group {
                flex-direction: column;
            }
            
          #stats .calc-input {
                min-width: 100px;
            }
            
           #stats body {
                padding: 15px;
            }
        }

.hashrate-row {
    display: flex;
    gap: 20px;
    align-items: flex-end;
}

.hashrate-input-section {
    flex: 1; /* Take up remaining space after units section */
}

.units-section {
    flex: 0 0 auto; /* Stay at natural width */
}

.hashrate-input-section .calc-input {
    width: 100%; /* Full width of its flex container */
    padding: 12px 15px;
    background: rgba(45, 55, 72, 0.8);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    color: #e2e8f0;
    font-size: 22px;
}

.units-section .unit-selector {
    background: rgba(128, 90, 213, 0.8);
    border: 1px solid rgba(128, 90, 213, 0.6);
    border-radius: 8px;
    color: #e2e8f0;
    padding: 12px 15px;
    font-size: 22px;
    font-weight: 500;
    cursor: pointer;
    min-width: 80px;
}


/*end css mining calculator*/
/*Begin css blocks in main stats*/
 
       

        #stats .dashboard-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        #stats .section {
            background: rgba(45, 45, 65, 0.8);
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #stats .section h4 {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 25px;
            color: #ffffff;
            text-align: left;
        }

        #stats .chart-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        #stats .pie-chart-wrapper {
            flex-shrink: 0;
            width: 240px;
            height: 240px;
            position: relative;
        }

        #stats .stats-table-wrapper {
            flex: 1;
            min-width: 0;
        }

        #stats .stats-table {
            width: 100%;
            border-collapse: collapse;
            background: transparent;  
            table-layout: auto;   /* instead of fixed */

        }

        #stats .stats-table thead {
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }

        #stats .stats-table th {
            text-align: left;
            padding: 8px 12px;
            font-weight: 600;
            color: #b0b0c0;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            word-wrap: break-word;
            hyphens: auto;
        }

        #stats .stats-table td {
            padding: 8px 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            vertical-align: middle;
            font-size: 22px;
            word-wrap: break-word;
            hyphens: auto;
        }

        #stats .stats-table tbody tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        #stats .miner-row {
            position: relative;
        }

        #stats .miner-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 10px;
            vertical-align: middle;
        }

        #stats .miner-name {
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 22px;
            color: #ffffff;
            font-weight: 500;
        }

        #stats .mining-pool {
            background: #ff6b35;
        }


        #stats .stat-value {
            font-weight: 600;
            color: #ffffff;
        }

        #stats .stat-secondary {
            color: #b0b0c0;
            font-size: 22px;
        }

        #stats .currency {
            color: #4caf50;
            font-weight: 600;
        }

        #stats .blocks-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        #stats .blocks-table th,
        #stats .blocks-table td {
            text-align: left;
            padding: 8px 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            word-wrap: break-word;
            hyphens: auto;
            font-size: 22px;
        }

        #stats .blocks-table th {
            background: rgba(255, 255, 255, 0.05);
            font-weight: 600;
            color: #b0b0c0;
            font-size: 22px;
        }

        #stats .blocks-table .hash {
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 20px;
            color: #64b5f6;
            word-wrap: break-word;
        }

        #stats .blocks-table .miner-cell {
            background: rgba(156, 39, 176, 0.2);
            color: #ce93d8;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 21px;
            display: inline-block;
            font-family: 'Monaco', 'Consolas', monospace;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px;
        }

        @media (max-width: 1024px) {
            #stats .chart-container {
                gap: 15px;
            }
            
            #stats .pie-chart-wrapper {
                width: 200px;
                height: 200px;
            }
        }

        @media (max-width: 768px) {
            #stats body {
                padding: 10px;
            }
            
            #stats .section {
                padding: 20px;
            }
            
            #stats .chart-container {
                flex-direction: column;
                gap: 15px;
            }
            
            #stats .pie-chart-wrapper {
                width: 100%;
                max-width: 240px;
                height: 240px;
                margin: 0 auto;
            }
            
            #stats .stats-table,
            #stats .blocks-table {
                font-size: 12px;
            }
            
            #stats .stats-table th,
            #stats .stats-table td,
            #stats .blocks-table th,
            #stats .blocks-table td {
                padding: 6px 8px;
            }
        }

        @media (max-width: 480px) {
            #stats section {
                padding: 15px;
            }
            
           #stats .stats-table,
            #stats  .blocks-table {
                font-size: 11px;
            }
            
            #stats .stats-table th,
           #stats .stats-table td,
            #stats .blocks-table th,
           #stats .blocks-table td {
                padding: 4px 6px;
            }
            
           #stats .pie-chart-wrapper {
                width: 100%;
                max-width: 200px;
                height: 200px;
            }
        }


        @media (max-width: 800px) {
    /* Hide Transaction Count column (5th column in recent stats table) */
    #stats .stats-table th:nth-child(5),
    #stats .stats-table td:nth-child(5) {
        display: none;
    }
    
    /* Hide % of Minted column (3rd column in both tables) */
    #stats .stats-table th:nth-child(3),
    #stats .stats-table td:nth-child(3) {
        display: none;
    }
    
    /* Make remaining columns more compact */
    #stats .stats-table {
        font-size: 9px;
    }
    
    #stats .stats-table th,
    #stats .stats-table td {
        padding: 2px 4px;
    }
    
    #stats .miner-name {
        font-size: 15px;
    }
    
    #stats .miner-indicator {
        width: 8px;
        height: 8px;
        margin-right: 6px;
    }
}


#stats a {
    color: #ffffff !important;
    text-decoration: none;
}

#stats a:hover {
    color: #64b5f6 !important;
    text-decoration: underline;
}

#stats a:visited {
    color: #ffffff !important;
}
/* Target only the MINER column */
#stats .stats-table th:first-child,
#stats .stats-table td:first-child {
    white-space: nowrap;
    word-wrap: normal;
    hyphens: none;
}

.miner-col {
  min-width: 250px;
  white-space: nowrap;
}



/*graphs*/
/* Solution 1: Maximum width with minimal spacing */
.chart-container {
    width: 1200px;
    height: 400px;
    margin: 10px 0; /* Minimal vertical spacing */
    padding: 0;
    position: relative;
}


/* Solution 2: Viewport-based sizing for maximum fill */
.full-width-chart {
    width: 100vw;
    height: 45vh; /* 45% of viewport height per chart */
    margin: 5px 0; /* Very minimal spacing */
    padding: 0;
    position: relative;
    box-sizing: border-box;
}

.full-width-chart canvas {
    width: 100% !important;
    height: 100% !important;
    aspect-ratio: unset !important;
}

/* Solution 3: Container that fills parent completely */
.charts-wrapper {
    width: 100%;
    height: 100vh; /* Full viewport height */
    display: flex;
    flex-direction: column;
    gap: 8px; /* Minimal gap between charts */
    padding: 4px;
    box-sizing: border-box;
}

.flex-chart-full {
    flex: 1; /* Each chart takes equal space */
    min-height: 0; /* Allow shrinking */
    position: relative;
}

.flex-chart-full canvas {
    width: 100% !important;
    height: 100% !important;
    aspect-ratio: unset !important;
}

/* Solution 4: CSS Grid for perfect space distribution */
.grid-charts-container {
    width: 100%;
    height: 100vh;
    display: grid;
    grid-template-rows: 1fr 1fr 1fr 1fr; /* 4 equal rows */
    gap: 6px;
    padding: 5px;
    box-sizing: border-box;
}

.grid-chart-item {
    position: relative;
    min-height: 0;
}

.grid-chart-item canvas {
    width: 100% !important;
    height: 100% !important;
    aspect-ratio: unset !important;
}

/* Solution 5: Two-column layout maximizing space */
.two-column-charts {
    width: 100%;
    height: 100vh;
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 1fr 1fr;
    gap: 8px;
    padding: 5px;
    box-sizing: border-box;
}

.two-column-chart {
    position: relative;
    min-height: 0;
}

.two-column-chart canvas {
    width: 100% !important;
    height: 100% !important;
    aspect-ratio: unset !important;
}

/* Solution 6: Single column with calculated heights */
.calculated-height-charts {
    width: 100%;
    padding: 5px;
}

.calc-chart {
    width: 100%;
    height: calc(25vh - 10px); /* 25% of viewport minus small margin */
    margin: 5px 0;
    position: relative;
}

.calc-chart canvas {
    width: 100% !important;
    height: 100% !important;
    aspect-ratio: unset !important;
}

/* Remove any default margins/padding that might create space */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body, html {
    width: 100%;
    height: 100%;
    overflow-x: hidden; /* Prevent horizontal scroll */
}

/* Override any existing chart styles */
#chart-hashrate-difficulty,
#chart-rewardtime,
#chart-pricetime,
#chart-AvgRevenue {
    width: 100% !important;
    height: 100% !important;
    aspect-ratio: unset !important;
    display: block !important;
    box-sizing: border-box !important;
}


#controlsGraph {
    margin-bottom: 20px;
    text-align: center;
}

#controlsGraph button {
    background: #4CAF50;
    color: white;
    border: none;
    padding: 10px 20px;
    margin: 5px;
    border-radius: 4px;
    cursor: pointer;
}

#controlsGraph button:hover {
    background: #45a049;
}

#stats-graphs h2 {
    text-align: center;
}


/* Solution 1: Force canvas sizing with viewport units */
.chart-container {
    width: 100%;
    height: 30%;
    margin: 4vh 0 !important;
    padding: 0;
    position: relative;
}

.chart-container canvas {
    width: 100% !important;
    height: 30% !important; /* Force canvas to match container */
    display: block !important;
}


#stats-graphs h2 {
    text-align: center;
    margin: 120px 0 60px 0 !important; /* Space around headings */
}
.chart-container {
    width: 100%;        /* full width of parent */
    max-width: 100vw;   /* prevent overflow */
    margin: 0 auto;
}

.chart-container > div {
    width: 100%;        /* full width of container */
    height: 400px;      /* or whatever height you want */
    max-height: 600px;  /* optional, limit height */
    position: relative; /* required for Chart.js canvas sizing */
}

    </style>
</head>
<body>



    <!-- B0x Stats Widget -->
    <div class="b0x-widget" id="b0x-widget"  style="display: none;">
        <div class="stat-item">
            <div class="stat-icon icon-dollar"></div>
            <div>
                <div class="stat-value" id="usd-price">$0.00</div>
                <div class="stat-label">USD</div>
            </div>
        </div>
        
        <div class="divider"></div>
        
        <div class="stat-item">
            <div class="stat-icon icon-0xbtc"></div>
            <div>
                <div class="stat-value" id="btc-price">0.000000</div>
                <div class="stat-label">0xBTC</div>
            </div>
        </div>
        
        <div class="divider"></div>
        
        <div class="stat-item">
            <div class="stat-icon icon-hash"></div>
            <div>
                <div class="stat-value" id="hashrate">0 H/s</div>
                <div class="stat-label">Hash</div>
            </div>
        </div>
    </div>


       <!-- Loading Widget -->
    <div id="loading-widget" class="loading-widget">
        <div class="loading-widget-header">
            <div class="loading-widget-spinner"></div>
            <div class="loading-widget-title">Loading</div>
            <button class="loading-widget-close" onclick="hideLoadingWidget()">âœ•</button>
        </div>
        <div class="loading-widget-message" id="loading-widget-message">
            Initializing...
        </div>
        <div class="loading-widget-progress">
            <div class="loading-widget-progress-bar" id="loading-progress-bar"></div>
        </div>
    </div>

    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loading-content">
            <div class="loader"></div>
            <div class="loading-title">DeFi Operations</div>
            <div class="loading-subtitle">Initializing your DeFi experience</div>
            <div class="loading-status" id="loading-status">Loading contracts...</div>
        </div>
    </div>
<!-- Main Content (hidden initially) -->
<div id="main-content">
    <div class="container">
        <!-- Header Section -->
        <div class="header">
            <!-- Chart positioned behind text -->
            <div class="chart-container">
                <canvas id="priceChart"></canvas>
            </div>
            <!-- Text content positioned over chart -->
            <div class="header-content">
                <div class="megapunch-only">B[]x DeFi</div>
                <p>Swap, Stake, and Manage Your Liquidity Positions</p>
            </div>
        </div>
        
        <!-- Navigation Tabs -->
        <div class="nav-tabs">
            <button class="nav-tab active" data-tab="swap" onclick="switchTab('swap')">Swap</button>
            <button class="nav-tab" data-tab="create" onclick="switchTab('create')">Create Position</button>
            <button class="nav-tab" data-tab="decrease" onclick="switchTab('increase')">Increase Liquidity</button>
            <button class="nav-tab" data-tab="decrease" onclick="switchTab('decrease')">Decrease Liquidity</button>
            <button class="nav-tab" data-tab="staking-main-page" onclick="switchTab('staking-main-page')">Staking</button>
            <button class="nav-tab" data-tab="stake-increase" onclick="switchTab('stake-increase')">Stake Increase</button>
            <button class="nav-tab" data-tab="stake-decrease" onclick="switchTab('stake-decrease')">Stake Decrease</button>
            <button class="nav-tab" data-tab="convert" onclick="switchTab('convert')">Convert 0xBTC <-> B0x</button>
            <button class="nav-tab" data-tab="settings" onclick="switchTab('settings')">Settings</button>
            <button class="nav-tab" data-tab="staking-management" onclick="switchTab('staking-management')">Stake Management</button>
            <button class="nav-tab" data-tab="testnet-faucet" onclick="switchTab('testnet-faucet')">Testnet Token Faucet</button>
            <button class="nav-tab" data-tab="contract-info" onclick="switchTab('contract-info')">Contract Info</button>
            <button class="nav-tab" data-tab="stats" onclick="switchTab('stats')">Live Statistics</button>
            <button class="nav-tab" data-tab="socials" onclick="switchTab('socials')">Social Media</button>
        </div>

        <!-- Stats Page -->
        <div id="stats" class="page">
            <br>
            <div class="info-card">
                <h3>Contract Live Statistics</h3>
                <p>View the Contracts Latest Live Statistics! Mining Calculator and Graphs!</p>
            </div>
            
            <!-- Sub-navigation for Stats -->
            <nav class="nav-tabs2">
                <button class="nav-tab2" data-tab="stats-home" onclick="switchTab2('stats-home')">Stats Home</button>
                <button class="nav-tab2" data-tab="stats-mining-calc" onclick="switchTab2('stats-mining-calc')">Mining calculator</button>
                <button class="nav-tab2" data-tab="stats-graphs" onclick="switchTab2('stats-graphs')">Graphs</button>
                <button class="nav-tab2" data-tab="stats-staking-rich-list" onclick="switchTab2('stats-staking-rich-list')">Staking Rich List</button>
            </nav>

            <!-- Stats Home Sub-Page -->
            <div id="stats-home" class="stats-page">
                <div class="stats-grid">
                    <div class="stat-row">
                        <span class="stat-label2">Price of 1 B ZERO X in USD</span>
                        <span class="stat-value2 stat-value-price">NaN <span class="unit">$</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Current Reward Era</span>
                        <span class="stat-value2 stat-value-currentEra">0 <span class="detail">/ 39 (next era: ~8.1 days @ 3.6 seconds a mint)</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Epoch Count</span>
                        <span class="stat-value2 stat-value-epochCount">4030</span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Mining Difficulty</span>
                        <span class="stat-value2 stat-value-difficulty">0.250 <span class="detail">(next: ~1.000)</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Estimated Hashrate</span>
                        <span class="stat-value2 stat-value-hashrate">292.47 <span class="detail eestHashRateUnit">Kh/s</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Current Average Reward Time</span>
                        <span class="stat-value2 stat-value-averageRewardTime">0.060 <span class="detail avgRewardUnit">minutes</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Current Average Reward</span>
                        <span class="stat-value2 stat-value-rewardPerSolve">25 <span class="detail rewardPerSolveUnit">B0x per solve</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Rewards Until Readjustment</span>
                        <span class="stat-value2 stat-value-blocksToGo">2 <span class="detail blocksToGoUnit">(~7.2 seconds)</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Time Until Emergency Adjustment Activated if all rewards not solved</span>
                        <span class="stat-value2 stat-value-emergency">13.9 <span class="detail emergencyUnit">days</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Last Difficulty Start Block</span>
                        <span class="stat-value2 stat-value-lastDiffBlock">30230154 <span class="detail lastDiffBlockDetail">(08-26-2025 12:16:36)</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Last Difficulty Time</span>
                        <span class="stat-value2 stat-value-lastDiffTime">1756228596 <span class="detail lastDiffBlockDetail2">(08-26-2025 12:16:36)</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Target Time</span>
                        <span class="stat-value2">10 <span class="unit">minutes</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Mined Supply Remaining in Era</span>
                        <span class="stat-value2 stat-value-remainingSupply">4,888,693 <span class="unit">B0x <span class="detail">(~195548 blocks)</span></span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Tokens distributed via Mining</span>
                        <span class="stat-value2 stat-value-distMining">10,861,306 <span class="unit">B0x</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Max Mined Supply for Current Era</span>
                        <span class="stat-value2 stat-value-MAxSupply">15,750,000 <span class="unit">B0x</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Token Holders</span>
                        <span class="stat-value2 stat-value-tokenHolders">128 <span class="unit">holders</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Token Transfers</span>
                        <span class="stat-value2 stat-value-tokenTransfers">10,720 <span class="unit">transfers</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Total Mints Transactions</span>
                        <span class="stat-value2 SuccessfulMintTransactions">10,720 <span class="unit">txs</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Total Contract Operations</span>
                        <span class="stat-value2 stat-value-contractOps">10,481 <span class="unit">txs</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Last Base Block Number</span>
                        <span class="stat-value2 stat-value-lastBaseBlock">30233764</span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Total Supply</span>
                        <span class="stat-value2 stat-value-AbsoluteMaxSupply">31,165,100 <span class="unit">B0x</span></span>
                    </div>
                </div>

                <button class="btn-secondary" onclick="GetContractStats()">GetContractStats</button>
                <button class="btn-secondary" onclick="updateAllMinerInfoFirst()">updateAllMinerInfoFirst</button>

                <!-- Miner Statistics Sections -->
                <div style="display:none;" id="row-miners2">
                    <div class="section">
                        <h4>Block distribution since last adjustment</h4>
                        <div class="chart-container">
                            <div class="pie-chart-wrapper">
                                <div id="blockdistributionpiechart2"></div>
                            </div>
                            <div class="stats-table-wrapper">
                                <table class="stats-table">
                                    <tbody id="minerstats2">
                                        <tr><td colspan="6">Loading info from the blockchain...</td></tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>

                <div style="display:none;" id="row-miners">
                    <div class="section">
                        <h4>Block distribution since launch</h4>
                        <div class="chart-container">
                            <div class="pie-chart-wrapper">
                                <div id="blockdistributionpiechart"></div>
                            </div>
                            <div class="stats-table-wrapper">
                                <table class="stats-table">
                                    <tbody id="minerstats">
                                        <tr><td colspan="5">Loading info from the blockchain...</td></tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>

                <div style="display:none;" id="row-blocks">
                    <div class="section">
                        <h4>Blocks solved since launch</h4>
                        <div class="stats-table-wrapper">
                            <table class="blocks-table">
                                <tbody id="blockstats">
                                    <tr><td colspan="5">Loading info from the blockchain...</td></tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Mining Calculator Sub-Page -->
            <div id="stats-mining-calc" class="stats-page">
                <div class="info-card">
                    <h3>B ZERO X (B0x) Mining Calculator</h3>
                    <p>Test different values to see your mining results!</p>
                </div>
                
                <div class="mining-calculator">
                    <div class="calculator-grid">
                        <div class="calculator-left">
                            <!-- Controls Box -->
                            <div class="controls-box">
                                <div class="input-group">
                                    <div class="hashrate-row">
                                        <div class="hashrate-input-section">
                                            <label class="input-label">Your Hashrate:</label>
                                            <input type="number" class="calc-input" placeholder="100.00" value="100" step="1" id="hashrate-input">
                                        </div>
                                        <div class="units-section">
                                            <label class="input-label">Units:</label>
                                            <select class="unit-selector" id="hashrate-unit">
                                                <option value="1">H/s</option>
                                                <option value="1000">kH/s</option>
                                                <option value="1000000" selected>MH/s</option>
                                                <option value="1000000000">GH/s</option>
                                                <option value="1000000000000">TH/s</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                                                
                                <div class="input-group">
                                    <label class="input-label">Difficulty:</label>
                                    <input type="number" class="calc-input difficulty-input" value="1" id="difficulty-input" step="0.00000001">
                                    <div class="button-group">
                                        <button class="calc-button secondary" id="current-diff-btn" onclick="useCurrentDiff()">USE CURRENT DIFF</button>
                                        <button class="calc-button secondary" id="next-diff-btn" onclick="useNextDiff()">USE NEXT DIFF</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="calculator-right">
                            <div class="results-section">
                                <h4 class="results-title">B ZERO X / B0x Solo Mining Results</h4>
                                
                                <div class="result-category">
                                    <h3 class="category-title">Block Timing</h3>
                                    <div class="result-item">
                                        <span class="result-label">Average time per block:</span>
                                        <span id="avg-block-time" class="result-value">0.0</span>
                                    </div>
                                    <div class="result-item">
                                        <span class="result-label">Time for 10 blocks:</span>
                                        <span id="realistic-block-time" class="result-value">0.0</span>
                                    </div>
                                </div>
                                
                                <div class="result-category">
                                    <h3 class="category-title">Daily Earnings Estimate</h3>
                                    <div class="result-item">
                                        <span class="result-label">Tokens per day (MAX):</span>
                                        <span id="max-tokens" class="result-value">0.00</span> B0x Tokens
                                    </div>
                                    <div class="result-note">
                                        Based on your calculated hashrate
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="how-it-works">
                    <h3 class="section-subtitle">How Does The Calculator Work?</h3>
                    <p class="explanation">At its heart is the standard hashrate equation:</p>
                    
                    <div class="formula-block">
                        <div class="formula-line">
                            time to solve a block in seconds = 
                            <div class="fraction">
                                <span class="formula-fraction">2<sup>22</sup> Ã— difficulty</span>
                                <span class="formula-divisor">hashrate</span>
                            </div>
                        </div>
                        
                        <div class="formula-line">
                            <span class="arrow">â†’</span> blocks per second = 
                            <div class="fraction">
                                <span class="formula-fraction">hashrate</span>
                                <span class="formula-divisor">2<sup>22</sup> Ã— difficulty</span>
                            </div>
                        </div>
                        
                        <div class="formula-line">
                            <span class="arrow">â†’</span> tokens per day = 
                            <span class="formula-complex">
                                <div class="fraction">
                                    <span class="formula-fraction">MIN: 6.25 tokens</span>
                                    <span class="formula-divisor">1 block</span>
                                </div>
                                <span class="operator">Ã—</span>
                                <div class="fraction">
                                    <span class="formula-fraction">60 seconds</span>
                                    <span class="formula-divisor">1 minute</span>
                                </div>
                            </span>
                            <span class="formula-complex">
                                <span class="operator">Ã—</span>
                                <div class="fraction">
                                    <span class="formula-fraction">60 minutes</span>
                                    <span class="formula-divisor">1 hour</span>
                                </div>
                                <span class="operator">Ã—</span>
                                <div class="fraction">
                                    <span class="formula-fraction">24 hours</span>
                                    <span class="formula-divisor">1 day</span>
                                </div>
                            </span>
                            <span class="operator">Ã—</span>
                            <div class="fraction">
                                <span class="formula-fraction">hashrate</span>
                                <span class="formula-divisor">difficulty</span>
                            </div>
                        </div>

                        <div class="formula-line">
                            <span class="arrow">â†’</span> tokens per day range = 
                            <div class="fraction">
                                <span class="formula-fraction">86400 Ã— hashrate Ã— (MIN 6.25 â†’ MAX 25)</span>
                                <span class="formula-divisor">2<sup>22</sup> Ã— difficulty</span>
                            </div>
                        </div>
                    </div>
                
                    <p class="reference">For a more detailed calculator and individual GPU benchmarks, visit:</p>
                    <ul class="reference-list">
                        <li><a href="#" class="reference-link">0xBTC Mining Calculator</a> by minerjoe78, milkers, and others</li>
                    </ul>
                </div>
            </div>

            <!-- Graphs Sub-Page -->
            <div id="stats-graphs" class="stats-page">
                <h3 class="section-title">Difficulty / Hashrate</h3>
                <p style="color: #888; text-align: center; margin-top: 50px;">Difficulty and hashrate charts coming soon...</p>

                <div id="topText">Loading blockchain data...</div>
                <div id="topText2">This may take a few minutes...</div>

                <div class="controls" id="controlsGraph">
                    <button onclick="updateGraphData(30, 30)">30 Days</button>
                    <button onclick="updateGraphData(60, 60)">60 Days</button>
                    <button onclick="updateGraphData(120, 120)">120 Days</button>
                </div>

                <h2>Difficulty & Hashrate</h2>
                <div class="chart-container">
                    <div id="difficultystats">Loading...</div>
                </div>

                <h2>Block Time & Supply</h2>
                <div class="chart-container">
                    <div id="blocktimestats">Loading...</div>
                </div>

                <h2>Price Over Time</h2>
                <div class="chart-container">
                    <div id="priceOverTimestats">Loading...</div>
                </div>

                <h2>Average Revenue for 31 GH/s</h2>
                <div class="chart-container">
                    <div id="avgRevenue">Loading...</div>
                </div>
            </div>

            <!-- Rich List Sub-Page -->
            <div id="stats-staking-rich-list" class="stats-page">
                <h3 class="section-title">Staking Rich List</h3>
                <p style="color: #888; text-align: center; margin-top: 50px;">
                    Staking Rich List coming soon... We will have Staked 0xBTC Balance, Staked B0x Balance, Total Liquidity. 
                    Get users and block via json webserver await fetch('https://data.bzerox.org/graph/staking_rich_list_testnet.j2son');. 
                    Then we log from that block First we need to check for all events increaseliqudiites, then we need to make 
                    a list of all users with over the minimum staking balance. Then we fetch all the users balances. batched
                </p>
            </div>
        </div>
    </div>
</div>

            <!-- Difficulty Sub-Page -->
            <div id="stats-graphs" class="stats-page">
                <h3 class="section-title">Difficulty / Hashrate</h3>
                <p style="color: #888; text-align: center; margin-top: 50px;">Difficulty and hashrate charts coming soon...</p>

    <div id="topText">Loading blockchain data...</div>
    <div id="topText2">This may take a few minutes...</div>

    <div class="controls" id="controlsGraph">
        <button onclick="updateGraphData(30, 30)">30 Days</button>
        <button onclick="updateGraphData(60, 60)">60 Days</button>
        <button onclick="updateGraphData(120, 120)">120 Days</button>
    </div>

        <h2>Difficulty & Hashrate</h2>
    <div class="chart-container">
        <div id="difficultystats">Loading...</div>
    </div>

        <h2>Block Time & Supply</h2>
    <div class="chart-container">
        <div id="blocktimestats">Loading...</div>
    </div>

        <h2>Price Over Time</h2>
    <div class="chart-container">
        <div id="priceOverTimestats">Loading...</div>
    </div>

        <h2>Average Revenue for 31 GH/s</h2>
    <div class="chart-container">
        <div id="avgRevenue">Loading...</div>
    </div>

            </div>
        </div>


        

    </div>




    <script>

var walletConnected = false;

var ProofOfWorkAddresss = "0x925C42A57328FD8a7b07ecA444A34963e07C8999";

// Function to get URL parameters
function getURLParameter(name) {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get(name);
}

// Function to switch tab on page load based on URL parameter
function initializeTabFromURL() {
    // Check for 'tab' parameter in URL (e.g., ?tab=convert)
    const tabParam = getURLParameter('tab');
    
    if (tabParam) {
        // List of valid tab names to prevent invalid tab switching
        const validTabs = [
            'swap',
            'create',
            'increase',
            'decrease',
            'staking-main-page',
            'stake-increase',
            'stake-decrease',
            'convert',
            'settings',
            'staking-management',
            'testnet-faucet',
            'contract-info',
            'stats',
            'socials'
        ];
        
        // Check if the tab parameter is valid
        if (validTabs.includes(tabParam)) {
            switchTab(tabParam);
        } else {
            console.warn(`Invalid tab parameter: ${tabParam}`);
            // Optionally switch to default tab
            switchTab('swap');
        }
    }
    // If no tab parameter, the default active tab will remain (swap)
}



// Alternative function if you prefer to use just the parameter name without 'tab='
// For URLs like ?convert instead of ?tab=convert
function initializeTabFromDirectParam() {
    const urlParams = new URLSearchParams(window.location.search);
    
    // Valid tab names
    const validTabs = [
        'swap',
        'create',
        'increase',
        'decrease',
        'staking-main-page',
        'stake-increase',
        'stake-decrease',
        'convert',
        'settings',
        'staking-management',
        'testnet-faucet',
        'contract-info',
        'stats',
        'socials'
    ];
    
    // Check if any of the valid tab names exist as parameters
    for (const tab of validTabs) {
        if (urlParams.has(tab)) {
            switchTab(tab);
            return; // Exit after first match to prevent multiple tab switches
        }
    }
}

// Run on page load
document.addEventListener('DOMContentLoaded', function() {
    // Use this for URLs like ?tab=convert
    initializeTabFromURL();
    
    // AND use this for URLs like ?convert
    initializeTabFromDirectParam();
});

function updateURL(tabName) {

    const baseUrl = window.location.origin + window.location.pathname;
    // Add a valueless parameter
    const newUrl = `${baseUrl}?${tabName}`;
    window.history.replaceState(null, '', newUrl);
}


    let PreviousTabName ="";

async function switchTab(tabName) {
            // Hide all pages
            const pages = document.querySelectorAll('.page');
            pages.forEach(page => page.classList.remove('active'));
            
            // Remove active class from all tabs
            const tabs = document.querySelectorAll('.nav-tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            // Show selected page
            document.getElementById(tabName).classList.add('active');
            
            // Add active class to clicked tab
            

            
            // Add active class to selected sub-tab and sub-page
            const selectedTab = document.querySelector(`[data-tab="${tabName}"]`);
            const selectedPage = document.getElementById(tabName);
            
            console.log('Selected tab:', selectedTab); // Debug log
            console.log('Selected page:', selectedPage); // Debug log
            
            if (selectedTab) selectedTab.classList.add('active');
            if (selectedPage) {
                selectedPage.classList.add('active');
                selectedPage.style.display = 'block'; // Force show
            }

            
            updateURL(tabName);
            console.log("PREVIOUS TAB NAME");
            if(tabName =='stats' && PreviousTabName !='stats'){
                switchTab2('stats-home');
                await GetContractStats();
                await updateAllMinerInfoFirst();
            }
            PreviousTabName = tabName;
            console.log("PREVIOUS TAB NAME: ",PreviousTabName);
    }


     // Sub-navigation function for stats section
        async function switchTab2(tabName) {
            console.log('switchTab2 called with:', tabName); // Debug log
            
            // Remove active class from all sub-tabs and sub-pages
            document.querySelectorAll('.nav-tab2').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.stats-page').forEach(page => {
                page.classList.remove('active');
                page.style.display = 'none'; // Force hide
            });


            
            // Add active class to selected sub-tab and sub-page
            const selectedTab = document.querySelector(`[data-tab="${tabName}"]`);
            const selectedPage = document.getElementById(tabName);
            
            console.log('Selected tab:', selectedTab); // Debug log
            console.log('Selected page:', selectedPage); // Debug log
            
            if (selectedTab) selectedTab.classList.add('active');
            if (selectedPage) {
                selectedPage.classList.add('active');
                selectedPage.style.display = 'block'; // Force show
            }

            if(tabName == "stats-graphs")
            {
            await initEthers();
            // Automatically load 30 days of data
            updateGraphData(30, 30);

            }
        }



        initializeDApp();

        function hideLoadingScreen() {
            document.getElementById('loading-screen').style.display = 'none';
            document.getElementById('main-content').style.display = 'block';
        }


        function showLoadingScreen() {
            const loadingScreen = document.getElementById('loading-screen');
            const loadingContent = loadingScreen.querySelector('.loading-content');

            const loadingSubtitle = loadingScreen.querySelector('.loading-subtitle');
            // Reset all animations by removing and re-adding the loading content
            loadingSubtitle.textContent = 'Now searching for Uniswap NFT Positions for user'; // Use textContent, not text
            const parent = loadingContent.parentNode;
            const newContent = loadingContent.cloneNode(true);
            parent.removeChild(loadingContent);
            parent.appendChild(newContent);

            // Show the loading screen
            loadingScreen.style.display = 'flex';
            document.getElementById('main-content').style.display = 'none';
        }

        // Loading screen management
        function updateLoadingStatus(message) {
            document.getElementById('loading-status').textContent = message;
        }

        /* Simulate your dApp initialization*/
        async function initializeDApp() {
            try {
                updateLoadingStatus('Connecting to blockchain...');
                await new Promise(resolve => setTimeout(resolve, 3000));

                updateLoadingStatus('Loading smart contracts...');
                await new Promise(resolve => setTimeout(resolve, 1500));

                updateLoadingStatus('Fetching data...');
                await new Promise(resolve => setTimeout(resolve, 1500));

                updateLoadingStatus('Initializing interface...');
                await new Promise(resolve => setTimeout(resolve, 1000));

                updateLoadingStatus('Ready!');
                await new Promise(resolve => setTimeout(resolve, 500));

                hideLoadingScreen();
            } catch (error) {
                console.error('Failed to initialize dApp:', error);
                updateLoadingStatus('Error loading dApp. Please refresh.');
            }
        }





        // Configuration constants
        const _MAXIMUM_TARGET_STR_OLD = "27606985387162255149739023449108101809804435888681546220650096895197184";  // 2**234
        const BWORK_RPC = 'https://base-mainnet.g.alchemy.com/v2/u6woRjFLe5-e3SfnCYFnfoTlgVUangV3';
        const BWORK_CONTRACT_ADDRESS = '0x2f38B1a516239739CdCD2C228D1Eb96E29800975';
        const BWORK_LAST_DIFF_START_BLOCK_INDEX = '4';
        const BWORK_ERA_INDEX = '5';
        const BWORK_TOKENS_MINTED_INDEX = '11';
        const BWORK_MINING_TARGET_INDEX = '6';
        
        const _SECONDS_PER_ETH_BLOCK = 2;
        const _IDEAL_BLOCK_TIME_SECONDS = 600;
        const _HASHRATE_MULTIPLIER = 2**22;
        const _CONTRACT_NAME = 'BWORK';
        
        // These will be initialized after ethers is ready
        let ethblockstart = 30413732;
        let adjustAverageRewardTimeGraph = 8;
        let searchPoints2 = 120;
        let latest_eth_block = null;
        let BWORK_latest_eth_block = null;
        let ethersProvider = null;
        let ethersSigner = null;
        let _ZERO_BN;
        let _MAXIMUM_TARGET_BN_OLD;
        let retryAt = 0;

        // Helper functions
        function el(selector) {
            return document.querySelector(selector);
        }

        function log(...args) {
            console.log(...args);
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function toReadableThousands(num) {
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'M';
            } else if (num >= 1000) {
                return (num / 1000).toFixed(1) + 'K';
            }
            return num.toString();
        }

        function toReadableThousandsLong(num) {
            return num.toLocaleString();
        }

        function toReadableHashrate(hashrate) {
            if (hashrate >= 1e12) {
                return (hashrate / 1e12).toFixed(2) + ' TH/s';
            } else if (hashrate >= 1e9) {
                return (hashrate / 1e9).toFixed(2) + ' GH/s';
            } else if (hashrate >= 1e6) {
                return (hashrate / 1e6).toFixed(2) + ' MH/s';
            } else if (hashrate >= 1e3) {
                return (hashrate / 1e3).toFixed(2) + ' KH/s';
            }
            return hashrate.toFixed(2) + ' H/s';
        }

        function ethBlockNumberToTimestamp(blockNumber) {
            // Use a more recent reference point for Base network
            // Block 34966000 â‰ˆ December 2024 (adjust this based on current date)
            const referenceBlock = 34966000;
            const referenceTimestamp = Date.now() / 1000; // Current timestamp
            const avgBlockTime = 2; // Base network block time
            
            const blockDifference = blockNumber - referenceBlock;
            const timeDifference = blockDifference * avgBlockTime;
            const blockTimestamp = referenceTimestamp + timeDifference;
            
            return new Date(blockTimestamp * 1000).toLocaleDateString();
        }

        function ethBlockNumberToTimestamp2(blockNumber) {
            const referenceBlock = 34966000;
            const referenceTimestamp = Date.now() / 1000;
            const avgBlockTime = 2;
            
            const blockDifference = blockNumber - referenceBlock;
            const timeDifference = blockDifference * avgBlockTime;
            const blockTimestamp = referenceTimestamp + timeDifference;
            
            return new Date(blockTimestamp * 1000).toLocaleDateString('en-US', {month: 'short', day: 'numeric'});
        }

        function BWORKethBlockNumberToDateStr(blockNumber) {
            return ethBlockNumberToTimestamp2(blockNumber);
        }

        function goToURLAnchor() {
            // Placeholder function
        }

        // Alternative approach - always try to add first, then switch
        async function switchToBaseMainnet() {
            const baseMainnetConfig = {
                chainId: '0x2105', // 8453 in hex (Base mainnet)
                chainName: 'Base',
                nativeCurrency: {
                    name: 'Ethereum',
                    symbol: 'ETH',
                    decimals: 18
                },
                rpcUrls: ['https://mainnet.base.org'],
                blockExplorerUrls: ['https://basescan.org/']
            };
            
            try {
                // Try to add the network first (this will do nothing if it already exists)
                await window.ethereum.request({
                    method: 'wallet_addEthereumChain',
                    params: [baseMainnetConfig]
                });
                console.log('Base Mainnet network added/confirmed');
                
                // Then switch to it
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: baseMainnetConfig.chainId }]
                });
                console.log('Switched to Base Mainnet network');
                
            } catch (error) {
                console.error('Error with Base Mainnet network:', error);
                throw new Error(`Failed to setup Base Mainnet network: ${error.message}`);
            }
        }

        var retryAt1123123123 = 0;
        // Initialize Ethers connection
        async function initEthers() {
            try {
                if (window.ethereum) {
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    await switchToBaseMainnet();
                    ethersProvider = new ethers.providers.Web3Provider(window.ethereum);
                    ethersSigner = ethersProvider.getSigner();
                } else {
                    ethersProvider = new ethers.providers.JsonRpcProvider(BWORK_RPC);
                }
                
                // Initialize BigNumber constants after ethers is ready
                _ZERO_BN = ethers.BigNumber.from(0);
                _MAXIMUM_TARGET_BN_OLD = ethers.BigNumber.from(_MAXIMUM_TARGET_STR_OLD);
                
                // Get latest block
                const latestBlock = await ethersProvider.getBlockNumber();
                BWORK_latest_eth_block = latestBlock;
                latest_eth_block = BWORK_latest_eth_block;
                
                log('Connected to Base Mainnet. Latest block:', BWORK_latest_eth_block);
            } catch (error) {
                console.error('Failed to connect to Ethereum:', error);
                // Initialize fallback values
                ethersProvider = new ethers.providers.JsonRpcProvider(BWORK_RPC);
                _ZERO_BN = ethers.BigNumber.from(0);
                _MAXIMUM_TARGET_BN_OLD = ethers.BigNumber.from(_MAXIMUM_TARGET_STR_OLD);
                // Use a fallback block number if connection fails
                try{
                    BWORK_latest_eth_block = await ethersProvider.getBlockNumber();
                    latest_eth_block = BWORK_latest_eth_block;
                }catch(error){
                    console.log("ERROR : ",error);
                    await sleep(2000 * retryAt1123123123**2);
                    await initEthers();
                    retryAt1123123123 +=1;
                    if(retryAt1123123123 > 3){
                        return;
                    }
                }
                retryAt1123123123=0;
            }
        }

        class contractValueOverTime {
            constructor(ethersProviderInstance, contract_address, storage_index, descriptor) {
                this.WAIT_DELAY_FIXED_MS = 120;
                this.WAIT_DELAY_ON_TIMEOUT_MS = 1500;
                this.ethersProvider = ethersProviderInstance;
                this.contract_address = contract_address;
                this.storage_index = storage_index;
                this.descriptor = descriptor;
                this.sorted = false;
                this.states = [];
                this.expected_state_length = 0;
                this.pending_requests = [];
            }

            get getValues() {
                return this.states;
            }

            printValuesToLog() {
                this.states.forEach((value) => {
                    log('block #', value[0], 'ts', value[2], 'value[1]:', value[1].toString());
                });
            }

            // Load cached blocks in range
            loadFromCache(startBlock, endBlock, timeRangeLabel) {
                const contractPrefix = BWORK_CONTRACT_ADDRESS.slice(0, 7); // Includes '0x' + 5 hex chars

                const key = `${this.descriptor}_${timeRangeLabel}_${contractPrefix}`;
                let cache = JSON.parse(localStorage.getItem(key)) || {};
                let results = [];

                for (let blockStr in cache) {
                    let block = parseInt(blockStr, 10);
                    if (block >= startBlock && block <= endBlock) {
                        let value_bn = ethers.BigNumber.from('0x' + cache[blockStr]);
                        results.push([block, value_bn, '']);
                    }
                }

                results.sort((a, b) => a[0] - b[0]);
                this.states.push(...results);
                this.expected_state_length += results.length;

                return results;
            }

            async addValuesInRange(start_eth_block, end_eth_block, num_search_points, tolerance = 100) {
                // Calculate step size
                const stepsize = Math.floor((end_eth_block - start_eth_block) / num_search_points);
                console.log('stepsize', stepsize, 'num_search_points', num_search_points);

                // Load cached blocks using num_search_points as the label
                const cached = this.loadFromCache(start_eth_block, end_eth_block, num_search_points);
                if (cached.length > 0) {
                    console.log(`Loaded ${cached.length} cached blocks for ${this.descriptor}_${num_search_points}`);
                }

                // Track loaded blocks globally
                const loadedBlocks = Array.from(this.states.map(s => s[0]));

                // Align end block to UTC midnight
                const d = new Date();
                const secondsSinceMidnight = (d.getTime() - d.setUTCHours(0,0,0,0)) / 1000;
                const blocksSinceMidnight = Math.floor(secondsSinceMidnight / _SECONDS_PER_ETH_BLOCK);
                const alignedEndBlock = end_eth_block - blocksSinceMidnight;

                // Collect blocks to fetch
                const blocks_to_fetch = [];
                for (let i = 0; i < num_search_points; i++) {
                    const block_num = alignedEndBlock - (stepsize * i);

                    // Reuse cached blocks within tolerance
                    const exists = loadedBlocks.some(b => Math.abs(b - block_num) <= tolerance);
                    if (!exists) {
                        blocks_to_fetch.push(block_num);
                    }
                }

                if (blocks_to_fetch.length > 0) {
                    await this.batchGetStorageAt(blocks_to_fetch);
                }
            }

            async batchGetStorageAt(blockNumbers, batchSize = 20) {
                blockNumbers = blockNumbers.filter(block => block >= ethblockstart);
                if (blockNumbers.length === 0) return;

                // Precompute storage slot once
                let storageSlot;
                if (this.storage_index?.slice(0, 2) == '0x') {
                    if (this.storage_index.length > 10) {
                        storageSlot = this.storage_index;
                    } else {
                        storageSlot = '0x' + ethers.BigNumber.from(this.storage_index.slice(2)).toHexString().slice(2);
                    }
                } else {
                    storageSlot = '0x' + ethers.BigNumber.from(this.storage_index).toHexString().slice(2);
                }

                for (let i = 0; i < blockNumbers.length; i += batchSize) {
                    const batch = blockNumbers.slice(i, i + batchSize);
                    const batchNumber = Math.floor(i/batchSize) + 1;
                    const totalBatches = Math.ceil(blockNumbers.length/batchSize);
                    
                    log(`Processing batch ${batchNumber}/${totalBatches} for ${this.descriptor}`);

                    try {
                        // Create all promises for the batch
                        const promises = batch.map(blockNum => 
                            this.ethersProvider.getStorageAt(
                                this.contract_address, 
                                storageSlot, 
                                Math.round(blockNum)
                            )
                            .then(value => this.processStorageValue(Math.round(blockNum), value))
                            .catch(error => {
                                console.error('Error fetching block', blockNum, ':', error);
                                // Fallback: add default value
                                return this.addValueAtEthBlock(blockNum);
                            })
                        );

                        // Execute all requests concurrently
                        await Promise.all(promises);
                        
                        this.expected_state_length += batch.length;

                        await sleep(200);
                        // Rate limiting between batches
                        if (i + batchSize < blockNumbers.length) {
                            await sleep(400);
                        }

                    } catch (error) {
                        console.error('Batch request failed:', error);
                        
                        // Fallback: process each block individually with retries
                        for (const blockNum of batch) {
                            try {
                                const value = await this.ethersProvider.getStorageAt(
                                    this.contract_address, 
                                    storageSlot, 
                                    Math.round(blockNum)
                                );
                                await this.processStorageValue(Math.round(blockNum), value);
                            } catch (individualError) {
                                console.error('Individual request also failed for block', blockNum, ':', individualError);
                                await this.addValueAtEthBlock(blockNum);
                            }
                            await sleep(200);
                        }
                    }
                }
            }

            async processStorageValue(eth_block_num, value) {
                if (!value || value == '0x') {
                    log('Got bad value for block', eth_block_num, ', retrying...');
                    await sleep(this.WAIT_DELAY_ON_TIMEOUT_MS);
                    return this.addValueAtEthBlock(eth_block_num, true);
                }

                var hex_str = value.substr(2, 64).replace(/[^0-9a-fA-F]/g, '').padStart(64, '0');

                try {
                    let value_bn;
                    if (this.storage_index.slice(0, 2) == '0x' && this.storage_index == '0xd66bf39be2869094cf8d2d31edffab51dc8326eadf3c7611d397d156993996da') {
                        var sqrtPriceX96 = BigInt('0x' + hex_str.slice(-40));
                        var Q96 = BigInt('79228162514264337593543950336');
                        value_bn = ethers.BigNumber.from(((sqrtPriceX96 * sqrtPriceX96) / (Q96 * Q96)).toString());
                    } else if (this.storage_index.slice(0, 2) == '0x') {
                        var sqrtPriceX96 = BigInt('0x' + hex_str.slice(-40));
                        var temp = Number(sqrtPriceX96) / (2**96);
                        var final_price = Math.floor((temp ** 2) * 10**12);
                        value_bn = ethers.BigNumber.from(final_price.toString());
                    } else {
                        value_bn = ethers.BigNumber.from('0x' + hex_str);
                    }
                    this.states.push([eth_block_num, value_bn, '']);
                } catch (error) {
                    console.error('Error processing storage value:', hex_str, 'Error:', error);
                }
            }

            addValueAtEthBlock(eth_block_num, is_retry, retry_delay = 600) {
                if (eth_block_num < ethblockstart) return;

                let cv_obj = this;
                if (!is_retry) this.expected_state_length++;

                let storageSlot;
                if (this.storage_index.slice(0, 2) == '0x') {
                    storageSlot = this.storage_index.length > 10 ? this.storage_index :
                        '0x' + ethers.BigNumber.from(this.storage_index.slice(2)).toHexString().slice(2);
                } else {
                    storageSlot = '0x' + ethers.BigNumber.from(this.storage_index).toHexString().slice(2);
                }

                this.ethersProvider.getStorageAt(this.contract_address, storageSlot, eth_block_num)
                    .then(this._getSaveStateFunction(this.states, eth_block_num, retry_delay))
                    .catch(async (error) => {
                        log('Error reading block storage:', error);
                        await sleep(retry_delay);
                        cv_obj.addValueAtEthBlock(eth_block_num, true, retry_delay * 2);
                    });
            }

            _getSaveStateFunction(block_states, eth_block_num, retry_delay) {
                let cv_obj = this;
                if (!retry_delay) retry_delay = cv_obj.WAIT_DELAY_ON_TIMEOUT_MS;

                return async function(value) {
                    if (!value || value == '0x') {
                        log('Bad value, retrying block', eth_block_num);
                        await sleep(retry_delay);
                        cv_obj.addValueAtEthBlock(eth_block_num, true, retry_delay * 2);
                        return;
                    }
                    await cv_obj.processStorageValue(eth_block_num, value);
                }
            }

            areAllValuesLoaded() {
                log("Expected:", this.expected_state_length, " vs cur Length:", this.states.length);
                return this.expected_state_length === this.states.length;
            }

            async waitUntilLoaded() {
                while (!this.areAllValuesLoaded()) await sleep(500);
            }

            sortValues() {
                log('sorting values..');
                this.states.sort((a, b) => a[0] - b[0]);
                this.sorted = true;
            }

            // Save states to localStorage for a given time range
            saveToLocalStorage(timeRangeLabel) {
                if (this.states.length === 0) return;
                const contractPrefix = BWORK_CONTRACT_ADDRESS.slice(0, 7); // Includes '0x' + 5 hex chars

                const key = `${this.descriptor}_${timeRangeLabel}_${contractPrefix}`;
                let cache = JSON.parse(localStorage.getItem(key)) || {};

                // Merge new states
                for (const [block, bnValue] of this.states) {
                    cache[block] = bnValue.toHexString().slice(2);
                }

                try {
                    localStorage.setItem(key, JSON.stringify(cache));
                    console.log(`Saved ${Object.keys(cache).length} unique blocks to ${key}`);
                } catch (error) {
                    console.error(`Failed to save ${key} to localStorage:`, error);
                }
            }

            // Compute UTC midnight block
            getMidnightBlock() {
                const d = new Date();
                d.setUTCHours(0, 0, 0, 0);
                const secondsSinceEpoch = Math.floor(d.getTime() / 1000);
                return ethblockstart + Math.floor(secondsSinceEpoch / _SECONDS_PER_ETH_BLOCK);
            }
        }

        function getHashrateDataFromDifficultyAndErasPerBlockData(difficulty_data, eras_per_block_data) {
            var expected_eras_per_block = 1/80; //76.5/* should be 40 times slower than ethereum (with 15-second eth blocks) */
            var difficulty_data_index = 0;
            var difficulty_change_block_num = 0;
            var chart_data = []
            for (var step = 0; step < eras_per_block_data.length; step++) {
                var current_eth_block = eras_per_block_data[step].x;
                var current_eras_per_block = eras_per_block_data[step].y;

                while(difficulty_data_index < difficulty_data.length - 1
                        && difficulty_data[difficulty_data_index+1].x < current_eth_block) {
                    difficulty_change_block_num = difficulty_data[difficulty_data_index+1].x;
                    difficulty_data_index += 1;
                }

                //console.log('diff chg @', difficulty_change_block_num);
                var difficulty =0
                try{
                    var difficulty = parseFloat(difficulty_data[difficulty_data_index].y.toString());
                }catch{
                }
                /* if difficulty change occurs within this step window */
                if (step != 0
                    && difficulty_data_index != 0
                    && eras_per_block_data[step].x > difficulty_change_block_num
                    && eras_per_block_data[step-1].x < difficulty_change_block_num) {

                    /* make a new half-way difficulty that takes the duration of each 
                       seperate difficulty into accout  */

                    var step_size_in_eth_blocks = eras_per_block_data[step].x - eras_per_block_data[step-1].x;
                    var diff1_duration = eras_per_block_data[step].x - difficulty_change_block_num;
                    var diff2_duration = difficulty_change_block_num - eras_per_block_data[step-1].x;
                    var current_difficulty =0
                    try{
                        current_difficulty = parseFloat(difficulty_data[difficulty_data_index].y.toString());
                    }catch{
                    }
                    /* NOTE: since the data is stored kind-of oddly (two values per
                       difficulty: both the first and last known block at that value), we
                       index difficulty_data as step-1 instead of step-2, skipping a
                       value. */
                    var last_difficulty = parseFloat(difficulty_data[difficulty_data_index-1].y.toString());
                    difficulty = (current_difficulty * (diff1_duration/step_size_in_eth_blocks))
                                 + (last_difficulty * (diff2_duration/step_size_in_eth_blocks));
                }

                var unadjusted_network_hashrate = difficulty * _HASHRATE_MULTIPLIER / _IDEAL_BLOCK_TIME_SECONDS;
                var network_hashrate = unadjusted_network_hashrate * (current_eras_per_block/expected_eras_per_block);
                //log('for block', current_eth_block, 'diff', difficulty.toFixed(1), 'uhr', unadjusted_network_hashrate, 'hr', network_hashrate)
                if(current_eth_block > ethblockstart){
                    chart_data.push({
                        x: current_eth_block,
                        y: network_hashrate,
                    })
                }
            }
            return chart_data;
        }

        function generateHashrateAndBlocktimeGraph(ethersProviderInstance, target_cv_obj, era_cv_obj, price_cv_obj, price_cv_obj3, tokens_minted_cv_obj) {
           el('#difficultystats').innerHTML = '<canvas id="chart-hashrate-difficulty"></canvas>';
            el('#blocktimestats').innerHTML  = '<canvas id="chart-rewardtime"></canvas>';
            el('#priceOverTimestats').innerHTML  = '<canvas id="chart-pricetime"></canvas>';
            el('#avgRevenue').innerHTML  = '<canvas id="chart-AvgRevenue"></canvas>';
            var target_values = target_cv_obj.getValues;
            var era_values = era_cv_obj.getValues;
            var tokens_minted_values = tokens_minted_cv_obj.getValues;
            var tokens_price_values = price_cv_obj.getValues;
            var tokens_price_values3 = price_cv_obj3.getValues;

            function convertValuesToChartData(values, value_mod_function) {
                var chart_data = []
                for (var i = 0; i < values.length; i++) {
                    if(values[i][1].isZero && values[i][1].isZero()) {
                        continue;
                    }
                    if(value_mod_function == undefined) {
                        value_mod_function = function(v){return v};
                    }
                    if(values[i][0] > ethblockstart){
                        chart_data.push({
                            x: values[i][0],
                            y: value_mod_function(values[i][1]),
                        })
                    }    
                }
                return chart_data;
            }

            function getErasPerBlockFromEraData(era_values) {
                var chart_data = []
                for (var step = 1; step < era_values.length; step++) {
                    var eth_blocks_passed = era_values[step][0] - era_values[step-1][0];
                    var eras_passed = parseFloat(era_values[step][1].toString()) - parseFloat(era_values[step-1][1].toString());

                    if (eth_blocks_passed == 0) {
                        continue;
                    }

                    var eras_per_eth_block = eras_passed / eth_blocks_passed * 7;

                    chart_data.push({
                        x: era_values[step][0],
                        y: eras_per_eth_block,
                    })
                }
                return chart_data;
            }

            var difficulty_data = convertValuesToChartData(target_values, 
                                                         (x)=>{return parseFloat(_MAXIMUM_TARGET_BN_OLD.div(x).toString())});
            
            // Set Chart.js defaults for dark theme
            Chart.defaults.color = '#f2f2f2';

            var era_data = convertValuesToChartData(era_values);
            var total_supply_data = convertValuesToChartData(tokens_minted_values, 
                                                           (x)=>{return parseFloat(ethers.utils.formatEther(x))});
            var total_price_data = convertValuesToChartData(tokens_price_values, 
                                                           (x)=>{return 1 / parseFloat(x.toString()) });
            var total_price_data3 = convertValuesToChartData(tokens_price_values3, 
                                                           (x)=>{return parseFloat(x.toString()) });

            const scaleFactor = 10000000;
            let resultGraph = total_price_data.map((item, index) => {
                if (total_price_data[index].y === 0) {
                    console.error("Division by zero at index " + index);
                    return null;
                }
                return {
                    x: item.x,
                    y:(item.y)*scaleFactor
                };
            });

            let result2 = total_price_data.map((item, index) => {
                if (total_price_data[index].y === 0) {
                    console.error("Division by zero at index " + index);
                    return null;
                }
                return {
                    x: item.x,
                    y: item.y
                };
            });

            let avgPriceAtTime = total_price_data3.map((item, index) => {
                if (result2[index] && result2[index].y !== 0) {
                    return {
                        x: item.x,
                        y: item.y * result2[index].y
                    };
                }
                return null;
            }).filter(item => item !== null);

            var eras_per_block_data = getErasPerBlockFromEraData(era_values);
            var average_reward_time_data = [];
            for(var i = 0; i < eras_per_block_data.length; i += 1) {
                if(eras_per_block_data[i].x > ethblockstart){
                    average_reward_time_data.push({
                        x: eras_per_block_data[i].x,
                        y: 1 / (eras_per_block_data[i].y * adjustAverageRewardTimeGraph),
                    })
                }
            }

            var hashrate_data = getHashrateDataFromDifficultyAndErasPerBlockData(difficulty_data, eras_per_block_data);

            console.log("hashrate_data :", hashrate_data);
            var max_hashrate_value = 0

            for (var i = 0; i < hashrate_data.length; i += 1) {
                /* get max hashrate data, note - not a BN */
                if (hashrate_data[i].y > max_hashrate_value) {
                    console.log("max_hashrate_value ", hashrate_data[i].y)
                    max_hashrate_value = hashrate_data[i].y;
                }
            }
            // Check if the last value in hashrate_data is 0 and remove it if true
            if (hashrate_data.length > 0 && hashrate_data[hashrate_data.length - 1].y === 0) {
                hashrate_data.pop();
            }

            var datasetCopy = [
                average_reward_time_data.slice(0, 1)[0], 
                average_reward_time_data.slice(average_reward_time_data.length-1, average_reward_time_data.length)[0],
            ]
            if (datasetCopy[0]) {
                datasetCopy[0] = Object.assign({}, datasetCopy[0]);
                datasetCopy[1] = Object.assign({}, datasetCopy[1]);
                datasetCopy[0].y = _IDEAL_BLOCK_TIME_SECONDS / 60;
                datasetCopy[1].y = _IDEAL_BLOCK_TIME_SECONDS / 60;
            }

            // Calculate revenue data
            let avgRevenue = [];
            if (avgPriceAtTime.length > 0 && difficulty_data.length > 0) {
                for (let i = 0; i < Math.min(avgPriceAtTime.length, difficulty_data.length); i++) {
                    if (avgPriceAtTime[i] && difficulty_data[i] && difficulty_data[i].y) {
                        let difficultyValue = difficulty_data[i].y;
                        
                        let revenue = (31000000000 * 4320000 * 8 / (10 * difficultyValue * 2**22)) * avgPriceAtTime[i].y;
                        avgRevenue.push({
                            x: difficulty_data[i].x,
                            y: revenue
                        });
                    }
                }
            }


            // Create Difficulty Chart
             // Create Difficulty Chart
            const difficultyCtx = document.getElementById('chart-hashrate-difficulty').getContext('2d');
            var hr_diff_chart = new Chart(difficultyCtx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: "Difficulty",
                        stepped: 'before',
                        backgroundColor: 'rgb(255, 99, 132)',
                        borderColor: 'rgb(255, 99, 132)',
                        data: difficulty_data,
                        fill: false,
                        tension: 0,
                        pointRadius: 1,
                        pointHoverRadius: 3,
                        borderWidth: 1,
                        yAxisID: 'y'
                    }, {
                        label: "Based Work Token Hashrate",
                        backgroundColor: 'rgb(156, 204, 101)',
                        borderColor: 'rgb(156, 204, 101)',
                        data: hashrate_data,
                        fill: false,
                        tension: 0,
                        pointRadius: 1,
                        pointHoverRadius: 3,
                        borderWidth: 1,
                        yAxisID: 'y1'
                    }]
                },
                options: { 
                    responsive: true,
                    maintainAspectRatio: false,
                    parsing: {
                        xAxisKey: 'x',
                        yAxisKey: 'y'
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            display: true,
                            position: 'bottom',
                            grid: {
                                display: true,
                                color: 'rgba(255, 255, 255, 0.1)',
                                drawOnChartArea: true
                            },
                            ticks: {
                                color: '#f2f2f2',
                                maxRotation: 45,
                                maxTicksLimit: 8,
                                callback: function(value, index, values) {
                                    return BWORKethBlockNumberToDateStr(Math.floor(value));
                                }
                            },
                            title: {
                                display: true,
                                text: 'Block Number',
                                color: '#f2f2f2',
                                font: {
                                    size: 11,
                                    weight: 'normal'
                                }
                            }
                        },
                        y: {
                            type: 'linear',
                            position: 'left',
                            display: true,
                            beginAtZero: true,
                            grace: '5%',
                            grid: {
                                display: true,
                                color: 'rgba(255, 255, 255, 0.1)',
                                drawOnChartArea: true
                            },
                            title: {
                                display: true,
                                text: 'Difficulty',
                                color: 'rgb(255, 99, 132)',
                                font: {
                                    size: 11,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                color: '#f2f2f2',
                                maxTicksLimit: 6,
                                callback: function(value, index, values) {
                                    return toReadableThousandsLong(value);
                                }
                            }
                        },
                        y1: {
                            type: 'linear',
                            position: 'right',
                            display: true,
                            beginAtZero: false,
                            grace: '5%',
                            grid: {
                                drawOnChartArea: false
                            },
                            title: {
                                display: true,
                                text: 'Hashrate (MH/s)',
                                color: 'rgb(156, 204, 101)',
                                font: {
                                    size: 11,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                color: '#f2f2f2',
                                maxTicksLimit: 6,
                                callback: function(value, index, values) {
                                    return toReadableHashrate(value);
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            labels: {
                                color: '#f2f2f2',
                                usePointStyle: true
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#f2f2f2',
                            bodyColor: '#f2f2f2',
                            borderColor: 'rgba(255, 255, 255, 0.3)',
                            borderWidth: 1,
                            callbacks: {
                                title: function(context) {
                                    return 'Block: ' + Math.floor(context[0].parsed.x);
                                }
                            }
                        }
                    }
                }
            });
// Solution 1: Set canvas size before creating chart
const rewardTimeCanvas = document.getElementById('chart-rewardtime');
const container = rewardTimeCanvas.parentElement;

// Calculate the actual size you want
const containerHeight = window.innerHeight * 0.35; // 35vh in pixels
const containerWidth = container.offsetWidth;

// Set canvas size explicitly
rewardTimeCanvas.style.width = containerWidth + 'px';
rewardTimeCanvas.style.height = containerHeight + 'px';



// Create Block Time & Supply Chart
const rewardTimeCtx = document.getElementById('chart-rewardtime').getContext('2d');
var rewardtime_chart = new Chart(rewardTimeCtx, {
    type: 'line',
    data: {
        datasets: [{
            label: "Average Reward Time",
            backgroundColor: 'rgb(79, 195, 247)',
            borderColor: 'rgb(79, 195, 247)',
            data: average_reward_time_data,
            fill: false,
            tension: 0,
            pointRadius: 1,
            pointHoverRadius: 3,
            borderWidth: 1,
            yAxisID: 'y'
        }, {
            label: 'Target Reward Time',
            backgroundColor: 'rgb(0, 255, 0)',
            borderColor: 'rgb(0, 255, 0)',
            borderDash: [5, 15],
            data: datasetCopy,
            fill: false,
            tension: 0,
            pointRadius: 0,
            pointHoverRadius: 3,
            borderWidth: 1,
            yAxisID: 'y'
        }, {
            label: "Total Supply",
            backgroundColor: 'rgb(255, 152, 0)',
            borderColor: 'rgb(255, 152, 0)',
            data: total_supply_data,
            fill: false,
            tension: 0,
            pointRadius: 1,
            pointHoverRadius: 3,
            borderWidth: 1,
            yAxisID: 'y1'
        }]
    },
    options: {
        responsive: true,
        maintainAspectRatio: false,
        parsing: {
            xAxisKey: 'x',
            yAxisKey: 'y'
        },
        interaction: {
            intersect: false,
            mode: 'index'
        },
        scales: {
            x: {
                type: 'linear',
                display: true,
                position: 'bottom',
                grid: {
                    display: true,
                    color: 'rgba(255, 255, 255, 0.1)',
                    drawOnChartArea: true
                },
                ticks: {
                    color: '#f2f2f2',
                    maxRotation: 45,
                    maxTicksLimit: 8,
                    callback: function(value, index, values) {
                        return BWORKethBlockNumberToDateStr(Math.floor(value));
                    }
                },
                title: {
                    display: true,
                    text: 'Block Number',
                    color: '#f2f2f2',
                    font: {
                        size: 11,
                        weight: 'normal'
                    }
                }
            },
            y: {
                type: 'linear',
                position: 'left',
                display: true,
                beginAtZero: false,
                grace: '5%',
                grid: {
                    display: true,
                    color: 'rgba(255, 255, 255, 0.1)',
                    drawOnChartArea: true
                },
                title: {
                    display: true,
                    text: 'Reward Time (Minutes)',
                    color: 'rgb(79, 195, 247)',
                    font: {
                        size: 11,
                        weight: 'bold'
                    }
                },
                ticks: {
                    color: '#f2f2f2',
                    maxTicksLimit: 6,
                    callback: function(value, index, values) {
                        return value.toFixed(1) + ' min';
                    }
                }
            },
            y1: {
                type: 'linear',
                position: 'right',
                display: true,
                beginAtZero: false,
                grace: '5%',
                grid: {
                    drawOnChartArea: false
                },
                title: {
                    display: true,
                    text: 'Total Supply (BWORK)',
                    color: 'rgb(255, 152, 0)',
                    font: {
                        size: 11,
                        weight: 'bold'
                    }
                },
                ticks: {
                    color: '#f2f2f2',
                    maxTicksLimit: 6,
                    callback: function(value, index, values) {
                        return toReadableThousands(value);
                    }
                }
            }
        },
        plugins: {
            legend: {
                display: true,
                labels: {
                    color: '#f2f2f2',
                    usePointStyle: true
                }
            },
            tooltip: {
                mode: 'index',
                intersect: false,
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#f2f2f2',
                bodyColor: '#f2f2f2',
                borderColor: 'rgba(255, 255, 255, 0.3)',
                borderWidth: 1,
                callbacks: {
                    title: function(context) {
                        return 'Block: ' + Math.floor(context[0].parsed.x);
                    }
                }
            }
        }
    }
});






// Create Price Chart
const priceTimeCtx = document.getElementById('chart-pricetime').getContext('2d');
var price_chart = new Chart(priceTimeCtx, {
    type: 'line',
    data: {
        datasets: [{
            label: "USD Price of 1 BWORK",
            backgroundColor: 'rgb(50, 205, 50)',
            borderColor: 'rgb(50, 205, 50)',
            data: avgPriceAtTime,
            fill: false,
            tension: 0,
            pointRadius: 1,
            pointHoverRadius: 3,
            borderWidth: 1,
            yAxisID: 'y'
        }, {
            label: "ETH Price of 1 BWORK",
            backgroundColor: 'rgb(158, 168, 219)',
            borderColor: 'rgb(158, 168, 219)',
            data: resultGraph,
            fill: false,
            tension: 0,
            pointRadius: 1,
            pointHoverRadius: 3,
            borderWidth: 1,
            yAxisID: 'y1'
        }]
    },
    options: {
        responsive: true,
        maintainAspectRatio: false,
        parsing: {
            xAxisKey: 'x',
            yAxisKey: 'y'
        },
        interaction: {
            intersect: false,
            mode: 'index'
        },
        scales: {
            x: {
                type: 'linear',
                display: true,
                position: 'bottom',
                grid: {
                    display: true,
                    color: 'rgba(255, 255, 255, 0.1)',
                    drawOnChartArea: true
                },
                ticks: {
                    color: '#f2f2f2',
                    maxRotation: 45,
                    maxTicksLimit: 8,
                    callback: function(value, index, values) {
                        return BWORKethBlockNumberToDateStr(Math.floor(value));
                    }
                },
                title: {
                    display: true,
                    text: 'Block Number',
                    color: '#f2f2f2',
                    font: {
                        size: 11,
                        weight: 'normal'
                    }
                }
            },
            y: {
                type: 'linear',
                position: 'left',
                display: true,
                beginAtZero: false,
                grace: '5%',
                grid: {
                    display: true,
                    color: 'rgba(255, 255, 255, 0.1)',
                    drawOnChartArea: true
                },
                title: {
                    display: true,
                    text: 'USD Price',
                    color: 'rgb(50, 205, 50)',
                    font: {
                        size: 11,
                        weight: 'bold'
                    }
                },
                ticks: {
                    color: '#f2f2f2',
                    maxTicksLimit: 6,
                    callback: function(value, index, values) {
                        return '$' + value.toFixed(4);
                    }
                }
            },
            y1: {
                type: 'linear',
                position: 'right',
                display: true,
                beginAtZero: false,
                grace: '5%',
                grid: {
                    drawOnChartArea: false
                },
                title: {
                    display: true,
                    text: 'ETH Price',
                    color: 'rgb(158, 168, 219)',
                    font: {
                        size: 11,
                        weight: 'bold'
                    }
                },
                ticks: {
                    color: '#f2f2f2',
                    maxTicksLimit: 6,
                    callback: function(value, index, values) {
                        return (value / scaleFactor).toFixed(8) + ' ETH';
                    }
                }
            }
        },
        plugins: {
            legend: {
                display: true,
                labels: {
                    color: '#f2f2f2',
                    usePointStyle: true
                }
            },
            tooltip: {
                mode: 'index',
                intersect: false,
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#f2f2f2',
                bodyColor: '#f2f2f2',
                borderColor: 'rgba(255, 255, 255, 0.3)',
                borderWidth: 1,
                callbacks: {
                    title: function(context) {
                        return 'Block: ' + Math.floor(context[0].parsed.x);
                    }
                }
            }
        }
    }
});






// Create Average Revenue Chart
const revenueCtx = document.getElementById('chart-AvgRevenue').getContext('2d');
var revenue_chart = new Chart(revenueCtx, {
    type: 'line',
    data: {
        datasets: [{
            label: "24 Hour Revenue @ 31 Gh/s",
            backgroundColor: 'rgb(50, 205, 50)',
            borderColor: 'rgb(50, 205, 50)',
            data: avgRevenue,
            fill: false,
            tension: 0,
            pointRadius: 1,
            pointHoverRadius: 3,
            borderWidth: 1,
            yAxisID: 'y'
        }]
    },
    options: {
        responsive: true,
        maintainAspectRatio: false,
        parsing: {
            xAxisKey: 'x',
            yAxisKey: 'y'
        },
        interaction: {
            intersect: false,
            mode: 'index'
        },
        scales: {
            x: {
                type: 'linear',
                display: true,
                position: 'bottom',
                grid: {
                    display: true,
                    color: 'rgba(255, 255, 255, 0.1)',
                    drawOnChartArea: true
                },
                ticks: {
                    color: '#f2f2f2',
                    maxRotation: 45,
                    maxTicksLimit: 8,
                    callback: function(value, index, values) {
                        return BWORKethBlockNumberToDateStr(Math.floor(value));
                    }
                },
                title: {
                    display: true,
                    text: 'Block Number',
                    color: '#f2f2f2',
                    font: {
                        size: 11,
                        weight: 'normal'
                    }
                }
            },
            y: {
                type: 'linear',
                position: 'left',
                display: true,
                beginAtZero: true,
                grace: '5%',
                grid: {
                    display: true,
                    color: 'rgba(255, 255, 255, 0.1)',
                    drawOnChartArea: true
                },
                title: {
                    display: true,
                    text: 'Daily Revenue (USD)',
                    color: 'rgb(50, 205, 50)',
                    font: {
                        size: 11,
                        weight: 'bold'
                    }
                },
                ticks: {
                    color: '#f2f2f2',
                    maxTicksLimit: 6,
                    callback: function(value, index, values) {
                        return '$' + value.toFixed(2);
                    }
                }
            }
        },
        plugins: {
            legend: {
                display: true,
                labels: {
                    color: '#f2f2f2',
                    usePointStyle: true
                }
            },
            tooltip: {
                mode: 'index',
                intersect: false,
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#f2f2f2',
                bodyColor: '#f2f2f2',
                borderColor: 'rgba(255, 255, 255, 0.3)',
                borderWidth: 1,
                callbacks: {
                    title: function(context) {
                        return 'Block: ' + Math.floor(context[0].parsed.x);
                    }
                }
            }
        }
    }
});





            goToURLAnchor(); 
        }

        async function show_progress(value){
            log('updating progress.. (', value, ')');
            el('#difficultystats').innerHTML = '<div class="">Loading info from the blockchain... <span style="font-weight:600;">' + value + '</span></div>';
            el('#blocktimestats').innerHTML = '<div class="">Loading info from the blockchain... <span style="font-weight:600;">' + value + '</span></div>';
            el('#priceOverTimestats').innerHTML = '<div class="">Loading info from the blockchain... <span style="font-weight:600;">' + value + '</span></div>';
            el('#avgRevenue').innerHTML = '<div class="">Loading info from the blockchain... <span style="font-weight:600;">' + value + '</span></div>';
        }

        async function updateHashrateAndBlocktimeGraph(ethersProviderInstance, start_eth_block, end_eth_block, num_search_points){
            console.log("123123Start search at: ",start_eth_block);
            console.log("123123end_eth_block: ",end_eth_block);
            
            // Create contract value trackers
            var last_diff_start_blocks = new contractValueOverTime(ethersProviderInstance, BWORK_CONTRACT_ADDRESS, BWORK_LAST_DIFF_START_BLOCK_INDEX, 'diffStartBlocks2');
            var era_values = new contractValueOverTime(ethersProviderInstance, BWORK_CONTRACT_ADDRESS, BWORK_ERA_INDEX, 'eraValues2');
            var tokens_minted_values = new contractValueOverTime(ethersProviderInstance, BWORK_CONTRACT_ADDRESS, BWORK_TOKENS_MINTED_INDEX, 'tokensMinted2');
            var tokens_price_values = new contractValueOverTime(ethersProviderInstance, '0x498581fF718922c3f8e6A244956aF099B2652b2b', '0xd66bf39be2869094cf8d2d31edffab51dc8326eadf3c7611d397d156993996da', 'BWORKETHPrice');
            var tokens_price_values3 = new contractValueOverTime(ethersProviderInstance, '0x498581fF718922c3f8e6A244956aF099B2652b2b', '0xe570f6e770bf85faa3d1dbee2fa168b56036a048a7939edbcd02d7ebddf3f948', 'USDCETHPrice');
            var mining_target_values = new contractValueOverTime(ethersProviderInstance, BWORK_CONTRACT_ADDRESS, BWORK_MINING_TARGET_INDEX, 'miningTargets2');

            // Load data with progress updates
            await tokens_price_values.addValuesInRange(start_eth_block, end_eth_block, num_search_points);
            await sleep(500);
            show_progress('10% [42 / 420]');

            await tokens_price_values3.addValuesInRange(start_eth_block, end_eth_block, num_search_points);
            await sleep(200);
            show_progress('20% [84 / 420]');

            await last_diff_start_blocks.addValuesInRange(start_eth_block, end_eth_block, num_search_points);
            await sleep(200);

            // Wait for completion with progress tracking
            while (!last_diff_start_blocks.areAllValuesLoaded() || !tokens_price_values.areAllValuesLoaded() || !tokens_price_values3.areAllValuesLoaded()) {
                let numerator = tokens_price_values.states.length + tokens_price_values3.states.length + last_diff_start_blocks.states.length;
                let denominator = tokens_price_values.expected_state_length + tokens_price_values3.expected_state_length + last_diff_start_blocks.expected_state_length;
                show_progress((50 * (numerator / denominator)).toFixed(0) + '% [' + (0.5 * numerator).toFixed(0) + ' / ' + denominator.toFixed(0) + ']');
                await sleep(1000);
            }

            await sleep(3000);

            await era_values.addValuesInRange(start_eth_block, end_eth_block, num_search_points);
            await sleep(500);
            show_progress('60% [250 / 420]');

            await tokens_minted_values.addValuesInRange(start_eth_block, end_eth_block, num_search_points);
            await sleep(500);
            show_progress('70% [350 / 420]');

            await mining_target_values.addValuesInRange(start_eth_block, end_eth_block, num_search_points);

            // Wait for all to complete
            await last_diff_start_blocks.waitUntilLoaded();
            await mining_target_values.waitUntilLoaded();
            await tokens_minted_values.waitUntilLoaded();
            await era_values.waitUntilLoaded();
            await tokens_price_values3.waitUntilLoaded();
            await tokens_price_values.waitUntilLoaded();

            // Sort and save data
            last_diff_start_blocks.sortValues();
            mining_target_values.sortValues();
            era_values.sortValues();
            tokens_minted_values.sortValues();
            tokens_price_values.sortValues();
            tokens_price_values3.sortValues();

            generateHashrateAndBlocktimeGraph(ethersProviderInstance, mining_target_values, era_values, tokens_price_values, tokens_price_values3, tokens_minted_values);
            
            document.getElementById('topText').style.display = 'none';
            document.getElementById('topText2').style.display = 'none';
            
            // Save to localStorage
            era_values.saveToLocalStorage(num_search_points);
            mining_target_values.saveToLocalStorage(num_search_points);
            last_diff_start_blocks.saveToLocalStorage(num_search_points);
            tokens_minted_values.saveToLocalStorage(num_search_points);
            tokens_price_values.saveToLocalStorage(num_search_points);
            tokens_price_values3.saveToLocalStorage(num_search_points);
        }

        function updateGraphData(history_days, num_search_points) {
            show_progress('0% [0 / 0]');

            setTimeout(async ()=>{
                while(BWORK_latest_eth_block == null) {
                    log('waiting for BWORK_latest_eth_block...');
                    await sleep(300);
                }

                const eth_blocks_per_day = 24*60*(60/_SECONDS_PER_ETH_BLOCK);
                log("_SECONDS_PER_ETH_BLOCK..."+eth_blocks_per_day);
            
                let max_blocks = history_days*eth_blocks_per_day;
                if (max_blocks / num_search_points > eth_blocks_per_day) {
                    log("WARNING: search points are greater than 1 day apart. Make sure you know what you are doing...");
                }

                num_search_points = history_days;   
                searchPoints2 = num_search_points
                let start_eth_block = (BWORK_latest_eth_block-max_blocks);
                if(start_eth_block < 30413732){
                    start_eth_block = 30413732;
                }
                  
                log("latest_eth_block..."+latest_eth_block);
                log("BWORK_latest_eth_block..."+BWORK_latest_eth_block);
                log("USING BWORK_LATEST_ETH_BLOCK RIGHT NOW BWORK_latest_eth_block..."+BWORK_latest_eth_block);
                log("latest_eth_block max_blocks..."+max_blocks);
                log("latest_eth_block...="+(latest_eth_block-max_blocks));
                log("latest_eth_block max_blocks..."+start_eth_block);
                let end_eth_block = BWORK_latest_eth_block-8;

                console.log("zz123123Start search at: ",start_eth_block);
                console.log("zz123123end_eth_block: ",end_eth_block);
                updateHashrateAndBlocktimeGraph(ethersProvider, start_eth_block, end_eth_block, num_search_points);

            }, 0); 
        }




















        




function getTimeUnits(seconds) {
    // Handle edge cases
    if (seconds < 0) {
        return { avgTime: 0, units: "seconds" };
    }
    
    // Define time conversion constants
    const MINUTE = 60;
    const HOUR = 60 * 60;
    const DAY = 24 * 60 * 60;
    const YEAR = 365.25 * 24 * 60 * 60; // Including leap years
    
    let avgTime, units;
    
    if (seconds < MINUTE) {
        // Less than 1 minute - show in seconds
        avgTime = parseFloat(seconds.toFixed(1));
        units = avgTime === 1 ? "second" : "seconds";
    } 
    else if (seconds < HOUR) {
        // Less than 1 hour - show in minutes
        avgTime = parseFloat((seconds / MINUTE).toFixed(1));
        units = avgTime === 1 ? "minute" : "minutes";
    } 
    else if (seconds < DAY) {
        // Less than 1 day - show in hours
        avgTime = parseFloat((seconds / HOUR).toFixed(1));
        units = avgTime === 1 ? "hour" : "hours";
    } 
    else if (seconds < YEAR) {
        // Less than 1 year - show in days
        avgTime = parseFloat((seconds / DAY).toFixed(1));
        units = avgTime === 1 ? "day" : "days";
    } 
    else {
        // 1 year or more - show in years
        avgTime = parseFloat((seconds / YEAR).toFixed(1));
        units = avgTime === 1 ? "year" : "years";
    }
    
    return {
        avgTime: avgTime,
        units: units
    };
}


async function getCurrentPrice(){

    
    return 1.00;
}


async function getAvgRewardTime(){

    
    return 1000;
}


function convertHashRateToReadable(hashratez){
   const units = ['H/s', 'KH/s', 'MH/s', 'GH/s', 'TH/s', 'PH/s'];
   let unitIndex = 0;
   let value = parseFloat(hashratez);
   
   while (value >= 1000 && unitIndex < units.length - 1) {
       value /= 1000;
       unitIndex++;
   }
   
   return {
       value: value.toFixed(2),
       units: units[unitIndex]
   }
}

function convertHashRateToReadable2(hashratez){
   const units = ['H/s', 'KH/s', 'MH/s', 'GH/s', 'TH/s', 'PH/s'];
   let unitIndex = 0;
   let value = parseFloat(hashratez);
   
   while (value >= 1000 && unitIndex < units.length - 1) {
       value /= 1000;
       unitIndex++;
   }
   
   return value.toFixed(2) + ' ' + units[unitIndex];
}


async function getHashrate(diffz,avgRewardTimez){
  var hashrate = (2**22*diffz)/avgRewardTimez;
  console.log("hashrate: ", hashrate);
  
  return hashrate;
}


async function getTarget(providera){
   const contractABI = [{"inputs":[],"name":"miningTarget","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}];
   const contract = new ethers.Contract(ProofOfWorkAddresss, contractABI, providera);
   const miningTarget = await contract.miningTarget();
   return miningTarget.toString();
}


async function getDifficulty(providera){
    var target = parseFloat(await getTarget(providera));
    var difficulty = ((2**253)/target) /  524_288;
    
var difficultyInput = document.getElementById("difficulty-input");

// Set its value to the new difficulty
difficultyInput.value = difficulty;
    return difficulty.toString();
}
var epochCount =0;
async function getEpochCount(providera) {
   const contractABI = [{"inputs":[],"name":"epochCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}];
   const contract = new ethers.Contract(ProofOfWorkAddresss, contractABI, providera);
   epochCount = await contract.epochCount();
   return epochCount.toString();
}


async function getAvgRewardTime(providera){
   const contractABI = [{"inputs":[],"name":"inflationMined","outputs":[{"internalType":"uint256","name":"YearlyInflation","type":"uint256"},{"internalType":"uint256","name":"EpochsPerYear","type":"uint256"},{"internalType":"uint256","name":"RewardsAtTime","type":"uint256"},{"internalType":"uint256","name":"TimePerEpoch","type":"uint256"}],"stateMutability":"view","type":"function"}];
   const contract = new ethers.Contract(ProofOfWorkAddresss, contractABI, providera);
   const result = await contract.inflationMined();
   return {
       YearlyInflation: result[0].toString(),
       EpochsPerYear: result[1].toString(),
       RewardsAtTime: result[2].toString(),
       TimePerEpoch: result[3].toString()
   };
}

async function getRewardPerSolve(){

    
    return 2511;
}

async function getBlocksToReadjust(providera) {
   const contractABI = [{"inputs":[],"name":"blocksToReadjust","outputs":[{"internalType":"uint256","name":"blocks","type":"uint256"}],"stateMutability":"view","type":"function"}];
   const contract = new ethers.Contract(ProofOfWorkAddresss, contractABI, providera);
   const blocks = await contract.blocksToReadjust();
   return blocks.toString();
}

async function getTimeEmergency(providera){
   const contractABI = [{"inputs":[],"name":"seconds_Until_adjustmentSwitch","outputs":[{"internalType":"uint256","name":"secs","type":"uint256"}],"stateMutability":"view","type":"function"}];
   const contract = new ethers.Contract(ProofOfWorkAddresss, contractABI, providera);
   const secs = await contract.seconds_Until_adjustmentSwitch();
   return secs.toString();
}



async function getLastDiffStartBlock(providera){

   const contractABI = [{"inputs":[],"name":"latestDifficultyPeriodStarted","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}];
   const contract = new ethers.Contract(ProofOfWorkAddresss, contractABI, providera);
   const latestDifficultyPeriodStarted2 = await contract.latestDifficultyPeriodStarted();
   return latestDifficultyPeriodStarted2.toString();
}


async function getLastDiffStartime(providera){

    
   const contractABI = [{"inputs":[],"name":"latestDifficultyPeriodStarted2","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}];
   const contract = new ethers.Contract(ProofOfWorkAddresss, contractABI, providera);
   const latestDifficultyPeriodStarted2 = await contract.latestDifficultyPeriodStarted2();
   return latestDifficultyPeriodStarted2.toString();
    return 130;
}


async function getRemainingSupplyINERA(providera, totalDistributedMining, maxperEra){

return maxperEra - totalDistributedMining;

    
}
async function getRemainingBlocksInEra(rewardPerSolve, totalDistributedMining, maxperEra){

return (maxperEra - totalDistributedMining)/rewardPerSolve;

    
}


async function getTransfers(providera){

    return 330;
    
}


async function getTotalOperations(providera){

    return 123123;
    
}


async function getLastBaseBlock(providera){
   const blockNumber = await providera.getBlockNumber();
   return blockNumber;
}


async function getRewardEra(providera){
   const contractABI = [{"inputs":[],"name":"rewardEra","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}];
   const contract = new ethers.Contract(ProofOfWorkAddresss, contractABI, providera);
   const rewardEra = await contract.rewardEra();
   return rewardEra.toString();
}



async function getTokenHolders(providera){

    return 1000;
}



async function getNextDifficulty(providera){

   const contractABI = [{"inputs":[],"name":"readjustsToWhatDifficulty","outputs":[{"internalType":"uint256","name":"newDifficulty","type":"uint256"}],"stateMutability":"view","type":"function"}];
   const contract = new ethers.Contract(ProofOfWorkAddresss, contractABI, providera);
   var newDifficulty = await contract.readjustsToWhatDifficulty();
   newDifficulty = newDifficulty/ 524288;
   
var difficultyInput = document.getElementById("difficulty-input");

// Set its value to the new difficulty
difficultyInput.value = newDifficulty;


   return newDifficulty.toString();

}

async function getAvgBlocksRemainingInEra(providera){

    return 313131313113131;
}


async function getTimestampFromBlock(blockNumber, providera){
    console.log("Block Number = ", blockNumber);
    
    // Convert to number if it's a string, or ensure it's an integer
    const blockNum = parseInt(blockNumber);
    
    const block = await providerTempStats.getBlock(blockNum);
    const timestamp = block.timestamp;
    
    // Convert to milliseconds and create Date object
    const date = new Date(timestamp * 1000);
    
    // Return formatted timestamp
    return date.toLocaleString();
}
async function getDaysUntilNextEra(providera){

    return {
        daysUntil: 123123,
        MintSpeed: 33333
    };    
}
async function getTokensMinted(providera) {
   const contractABI = [{"inputs":[],"name":"tokensMinted","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}];
   const contract = new ethers.Contract(ProofOfWorkAddresss, contractABI, providera);
   const tokensMinted = await contract.tokensMinted() /1e18;
   return tokensMinted.toString();
}
async function getMaxSupplyForEra(providera) {
   const contractABI = [{"inputs":[],"name":"maxSupplyForEra","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}];
   const contract = new ethers.Contract(ProofOfWorkAddresss, contractABI, providera);
   const maxSupplyForEra = await contract.maxSupplyForEra() /1e18;
   return maxSupplyForEra.toString();
}








/* colors used by pool names. todo: move to css, still use them for chart.js */
var pool_colors = {
  orange      : "#C64500",
  purple      : "#4527A0", // note: purple looks a lot like blue
  blue        : "#0277BD",
  green       : "#2E7D32",
  yellow      : "#997500",
  darkpurple  : "#662354",
  darkred     : "hsl(356, 48%, 30%)",
  teal        : "#009688",
  red         : "#f44336",
  slate       : "#34495e",
  brightred   : "#C62828",
  royal       : "#0070bc",
  pink        : "#EC407A",
  grey        : "#78909c",

  /* colors below here are not assigned yet */
  lightpurple : "#9c27b0",
  lime        : "#cddc39",
  brown       : "#8d6e63",
}





async function fetchTransactionsData(miner_blk_cnt) {
    try {
        // Fetching the transactions data from the GitHub API
        const response = await fetch('https://raw.githubusercontent.com/BasedWorkToken/Based-Work-Token-General/main/api/CostScript/saveFiles/BWORK_transaction_analysis_cost_summary.json');
        const transactionsData = await response.json();
        console.log("API DATA: ", transactionsData);
        const combinedData = combineWithMinerData(miner_blk_cnt, transactionsData);
        console.log("Combined Data: ", combinedData);
        return combinedData;
    } catch (error) {
        console.error("Error fetching transaction data: ", error);
        throw error; // Rethrow if you want to handle it elsewhere
    }
}

function combineWithMinerData(miner_blk_cnt, transactionsData) {
    // Prepare a new data structure to hold combined data
    var combinedData = [];
    console.log("Miner Block Count: ", miner_blk_cnt);
    console.log("Transactions Data: ", transactionsData);

    // Loop through the miner_blk_cnt array to find matches with transactions data
    for (const address of miner_blk_cnt) {
        // Convert the miner address to lowercase for comparison
        const lowerCaseAddress = address.toLowerCase();
        
        // Find corresponding transaction entry for the address
        const transactionEntry = transactionsData.find(entry => entry.from.toLowerCase() === lowerCaseAddress);
        
        if (transactionEntry) {
            combinedData.push({
                address: address,
                totalValue: transactionEntry.total_value,
                totalCost: transactionEntry.total_cost,
                transactionCount: transactionEntry.transaction_count
            });
        } else {
            // If no match found, still store the miner data with nulls for the transaction data
            combinedData.push({
                address: address,
               	 totalValue: null,
                totalCost: null,
                transactionCount: null
            });
        }
    }

    // Example of how to use the combined data
    console.log("Combined Data: ", combinedData);
    return combinedData;
}

function showBlockDistributionPieChart(piechart_dataset, piechart_labels) {
  //console.log('dataset', piechart_dataset);
    document.querySelector('#row-miners').style.display = 'block';
  document.querySelector('#blockdistributionpiechart').innerHTML = '<canvas id="chart-block-distribution" width="2rem" height="2rem"></canvas>';

  if(piechart_dataset.length == 0 || piechart_labels.length == 0) {
    return;
  }

  //Chart.defaults.global.elements.arc.backgroundColor = 'rgba(255,0,0,1)';
Chart.defaults.elements.arc.borderColor = 'rgb(32, 34, 38)';
Chart.defaults.elements.arc.borderWidth = 3;

  /* hashrate and difficulty chart */
  var hr_diff_chart = new Chart(document.getElementById('chart-block-distribution').getContext('2d'), {
    type: 'doughnut',

    data: {
        datasets: [piechart_dataset],
        labels: piechart_labels,
    },

    options: {
      legend: {
        display: false,
      },
    },
  });
}

function showBlockDistributionPieChart2(piechart_dataset, piechart_labels) {
  //console.log('dataset', piechart_dataset);
    document.querySelector('#row-miners2').style.display = 'block';
  document.querySelector('#blockdistributionpiechart2').innerHTML = '<canvas id="chart-block-distribution2" width="2rem" height="2rem"></canvas>';


  if(piechart_dataset.length == 0 || piechart_labels.length == 0) {
    return;
  }

  //Chart.defaults.global.elements.arc.backgroundColor = 'rgba(255,0,0,1)';
Chart.defaults.elements.arc.borderColor = 'rgb(32, 34, 38)';
Chart.defaults.elements.arc.borderWidth = 3;

  /* hashrate and difficulty chart */
  var hr_diff_chart = new Chart(document.getElementById('chart-block-distribution2').getContext('2d'), {
    type: 'doughnut',

    data: {
        datasets: [piechart_dataset],
        labels: piechart_labels,
    },

    options: {
      legend: {
        display: false,
      },
    },
  });
}

function getMinerColor(address, known_miners) {
  function simpleHash(seed, string) {
    var h = seed;
    for (var i = 0; i < string.length; i++) {
      h = ((h << 5) - h) + string[i].codePointAt();
      h &= 0xFFFFFFFF;
    }
    return h;
  }

  if(known_miners[address] !== undefined) {
    var hexcolor = known_miners[address][2];
  } else {
	  var test = (simpleHash(2, address) % 360)
	  if((simpleHash(2, address) % 360) < 0){
		  test = (simpleHash(2, address) % 360) + 360
		  
	  }
    hexcolor = 'hsl(' + test + ', 48%, 30%)';
  }
	if(address == "0xfaf20e5ca7e39d43a3aabc450602b4147c3aa62e"){
	//console.log("hex color: ", hexcolor);
	}
  return hexcolor;
}



var known_miners = {
  "0x49228d306754af5d16d477149ee50bef5ca286be" : [ "BWORK Mining Pool", "http://pool.basedworktoken.org/",     pool_colors.orange ], // mint helper contract (old)
  "0x98181a5f3b91117426331b54e2a47e8fa74f56b0" : [ "BWORK Mining Pool", "http://pool.basedworktoken.org/",     pool_colors.orange ], // mint helper contract (old)
  "0xce2e772f8bcf36901bacf31dfc67e38954e15754" : [ "Mineable Token Pool", "https://pool.0xmt.com/",     pool_colors.orange ], // mint helper contract (old)
  "0xeabe48908503b7efb090f35595fb8d1a4d55bd66" : [ "ABAS Mining Pool", "http://pool.abastoken.org/",     pool_colors.orange ], // mint helper contract
  "0x53ce57325c126145de454719b4931600a0bd6fc4" : [ "0xPool",            "http://0xPool.io",               pool_colors.purple ], // closed sometime 2018
  "0x98b155d9a42791ce475acc336ae348a72b2e8714" : [ "0xBTCpool",         "http://0xBTCpool.com",           pool_colors.blue ],
  "0x363b5534fb8b5f615583c7329c9ca8ce6edaf6e6" : [ "mike.rs pool",      "http://mike.rs",                 pool_colors.green ],
  "0x50212e78d96a183f415e1235e56e64416d972e93" : [ "mike.rs pool",      "http://mike.rs",                 pool_colors.green ], // mint helper contract
  "0x02c8832baf93380562b0c8ce18e2f709d6514c60" : [ "mike.rs pool B",    "http://b.mike.rs",               pool_colors.green ],
  "0x8dcee1c6302232c4cc5ce7b5ee8be16c1f9fd961" : [ "Mine0xBTC",         "http://mine0xbtc.eu",            pool_colors.darkpurple ],
  "0x20744acca6966c0f45a80aa7baf778f4517351a4" : [ "PoolOfD32th",       "http://0xbtc.poolofd32th.club",  pool_colors.darkred ],
  "0xd4ddfd51956c19f624e948abc8619e56e5dc3958" : [ "0xMiningPool",      "http://0xminingpool.com/",       pool_colors.teal ],
  "0x88c2952c9e9c56e8402d1b6ce6ab986747336b30" : [ "0xbtc.wolfpool.io", "http://wolfpool.io/",            pool_colors.red ],
  "0x540d752a388b4fc1c9deeb1cd3716a2b7875d8a6" : [ "tosti.ro",          "http://0xbtc.tosti.ro/",               pool_colors.slate ],
  "0xbbdf0402e51d12950bd8bbd50a25ed1aba5615ef" : [ "ExtremeHash",       "http://0xbtc.extremehash.io/",   pool_colors.brightred ],
  "0x7d28994733e6dbb93fc285c01d1639e3203b54e4" : [ "Wutime.com",        "http://wutime.com/",             pool_colors.royal ],
  "0x02e03db268488716c161721663501014fa031250" : [ "xb.veo.network",    "https://xb.veo.network:2096/",   pool_colors.pink ],
  "0xbf39de3c506f1e809b4e10e00dd22eb331abf334" : [ "xb.veo.network",    "https://xb.veo.network:2096/",   pool_colors.pink ],
  "0x5404bd6b428bb8e326880849a61f0e7443ef5381" : [ "666pool",           "http://0xbtc.666pool.cn/",       pool_colors.grey ],
  "0x7d3ebd2b56651d164fc36180050e9f6f7b890e9d" : [ "MVIS Mining Pool",  "http://mvis.ca",                 pool_colors.blue ],  // added 2020-02-23
  "0xd3e89550444b7c84e18077b9cbe3d4e3920f257d" : [ "0xPool",            "https://0xpool.me/", pool_colors.purple ], // added 2021-12-28, its a combo 0xBTC + BNBTC pool
  "0x6917035f1deecc51fa475be4a2dc5528b92fd6b0" : [ "PiZzA pool",        "http://gpu.PiZzA",               pool_colors.yellow ],
  "0x693d59285fefbd6e7be1b87be959eade2a4bf099" : [ "PiZzA pool",        "http://gpu.PiZzA",               pool_colors.yellow ],
  "0x697f698dd492d71734bcaec77fd5065fa7a95a63" : [ "PiZzA pool",        "http://gpu.PiZzA",               pool_colors.yellow ],
  "0x69ebd94944f0dba3e9416c609fbbe437b45d91ab" : [ "PiZzA pool",        "http://gpu.PiZzA",               pool_colors.yellow ],
  "0x69b85604799d16d938835852e497866a7b280323" : [ "PiZzA pool",        "http://gpu.PiZzA",               pool_colors.yellow ],
  "0x69ded73bd88a72bd9d9ddfce228eadd05601edd7" : [ "PiZzA pool",        "http://gpu.PiZzA",               pool_colors.yellow ],
}




function getMinerName(address, known_miners) {
  if(known_miners[address] !== undefined) {
    return known_miners[address][0];
  } else {
    return address.substr(0, 14) + '...';
  }
}

function getMinerNameLinkHTML(address, known_miners) {
  var hexcolor = getMinerColor(address, known_miners);
	if(address == "0xfaf20e5ca7e39d43a3aabc450602b4147c3aa62e"){
	//console.log("Link HTML Color: ", hexcolor);
	}
  var poolstyle = '<span style="background-color: ' + hexcolor + ';" class="miner-name">';

  if(known_miners[address] !== undefined) {
    var readable_name = known_miners[address][0];
    var address_url = known_miners[address][1];
  } else {
    var readable_name = address.substr(0, 14) + '...';
    var address_url = _BLOCK_EXPLORER_ADDRESS_URL + address;
  }

  return '<a href="' + address_url + '" target="_blank">' + poolstyle + readable_name + '</span></a>';
}

function getMinerAddressFromTopic(topic) {
  return '0x' + topic.substr(26, 41);
}



const _MINT_TOPIC = "0xcf6fbb9dcea7d07263ab4f5c3a92f53af33dffc421d9d121e1c74b307e68189d";

var _BLOCK_EXPLORER_ADDRESS_URL = 'https://sepolia.basescan.org/address/';
var _BLOCK_EXPLORER_TX_URL = 'https://sepolia.basescan.org/tx/';
var _BLOCK_EXPLORER_BLOCK_URL = 'https://sepolia.basescan.org/block/';

/* TODO use hours_into_past */
async function updateAllMinerInfoFirst(){
    if(!walletConnected){
       await connectTempRPCforStats();
    }
    var provids = provider;
    if(!walletConnected){
        provids=providerTempStats;
    }
    updateAllMinerInfo(provids);



}


/* sleep for given number of milliseconds. note: must be called with 'await' */
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

let previousEpochCount = null; // Initialize outside the loop

async function updateAllMinerInfo(provider){
  console.log('updateAllMinerInfo');

 var previousChallenge = "0x0";
var totalZKBTC_Mined = [];
  /* array of arrays of type [eth_block, txhash, miner_addr] */
  var mined_blocks = [];
var totalZKTC_Calculated = 0;
	var totalZKBTC_Mined_HASH = {};
  /* dict where key=miner_addr and value=total_mined_block_count */
  var miner_block_count = {};
  var miner_block_count2 = {};
  var miner_block_countHASH = {};
  /* total number of blocks mined since last difficulty adjustment */
  var total_mint_count_HASH = {};
  var total_block_count = 0;
  var total_tx_count = 0;
  var last_imported_mint_block = 0;
var total_TOTAL_mint_count_HASH = 0;


    var EpochCountBeforeCall = epochCount;
  var last_reward_eth_block =lastBaseBlock;
  var current_eth_block = currentBlock;
  var estimated_network_hashrate =estHashrate;
  var last_difficulty_start_block = lastDifficultyStartBlock;
    console.log("last_difficulty_start_block: ",last_difficulty_start_block);
  // check to see if the browser has any data in localStorage we can use.
  // don't use the data, though, if it's from an old difficulty period
    try {
    // Load local storage data first
    var last_diff_block_storage = Number(localStorage.getItem('lastDifficultyStartBlock_EraBitcoin2_afbRAFFABC_B0x1'));
    last_imported_mint_block = Number(localStorage.getItem('lastMintBlock_EraBitcoin2_afbRAFFABC_B0x1'));
    previousChallenge = JSON.parse(localStorage.getItem('mintData_GreekWedding2_B0x1'));
    console.log("previous ended challenge is this, starting here");
    var mint_data = localStorage.getItem('mintData_EraBitcoin2_afbRAFFABC_B0x1');

    console.log('last_imported_mint_block: ',last_imported_mint_block);
    let localMinedBlocks = [];
    let localLatestBlock = 0;

    if (mint_data !== null) {
      localMinedBlocks = JSON.parse(mint_data);
      // Find the highest block number in local data
      localLatestBlock = last_imported_mint_block;
      console.log('Local storage has', localMinedBlocks.length, 'blocks, latest:', localLatestBlock);
    }

    // Fetch remote data
    let remoteMinedBlocks = [];
    let remoteLatestBlock = 0;
    try {
      const response = await fetch('https://data.bzerox.org/graph/mined_blocks_testnet.j2son');
      if (response.ok) {
        const remoteData = await response.json();
        remoteMinedBlocks = remoteData.mined_blocks;
        remoteLatestBlock = remoteData.latest_block_number
        console.log('Remote data has', remoteMinedBlocks.length, 'blocks, latest:', remoteLatestBlock);
        
        // Update previousChallenge if available in remote data
        if (remoteData.previous_challenge) {
          previousChallenge = remoteData.previous_challenge;
        }
      }
    } catch (fetchError) {
      console.log('Error fetching remote data:', fetchError.message);
    }

    // Compare and choose the best dataset
    if (remoteLatestBlock > localLatestBlock) {
      console.log('Using REMOTE data (more recent)');
      mined_blocks = remoteMinedBlocks;
      last_imported_mint_block = remoteLatestBlock;
      
      // Update localStorage with remote data
      localStorage.setItem('mintData_EraBitcoin2_afbRAFFABC_B0x1', JSON.stringify(remoteMinedBlocks));
      localStorage.setItem('lastMintBlock_EraBitcoin2_afbRAFFABC_B0x1', remoteLatestBlock.toString());
      if (previousChallenge) {
        localStorage.setItem('mintData_GreekWedding2_B0x1', JSON.stringify(previousChallenge));
      }
    } else {
      console.log('Using LOCAL data');
      mined_blocks = localMinedBlocks;
      last_imported_mint_block = localLatestBlock;
    }

    // Process the chosen mined_blocks array
    console.log('imported', mined_blocks.length, 'transactions');

    var index2=0;
    var allepochs = 0;
    var maxMinedBlocksEpoch = 0;
    mined_blocks.forEach(function(mintData) {
      //  console.log("Mint data stuff mintData: ",mintData);
       // console.log("Mint data stuff mined_blocks[index + 1][4]: ",mined_blocks[index2 + 1][4]);

    maxMinedBlocksEpoch = mined_blocks[0][4];
    // Get the next block's epoch count
        var epochCount = mintData[4];
    var nextEpochCnt = null;
    if (index2 + 1 < mined_blocks.length && mined_blocks[index2 + 1][4] != undefined) {
        nextEpochCnt = mined_blocks[index2 + 1][4];
     //  console.log("Mint data stuff mined_blocks[index + 1][4]: ", nextEpochCnt);
    } else {
        console.log("Mint data stuff mined_blocks[index + 1][4]: No next element, mined_blocks[index2]: ",mined_blocks[index2]);
    }
    
    if (nextEpochCnt !== null) {  // Added check for nextEpochCnt !== 0
        // Use next transaction's epoch count
        epchCount = epochCount - nextEpochCnt;
    }else{
        epchCount= epochCount;
    }
    index2 =index2+1;

    var epochsMined = epchCount;

      //  console.log("\n\n\n\n\nEpochs Mined : ", epochsMined);
        allepochs = allepochs + epochsMined;
     //   console.log("Epochs Mined allepochs: ", allepochs);
        //console.log("Epochs Mined allepochs: ", allepochs,"\n\n");
        try{
       // console.log("Epochs Mined miner_block_countHASH[mintData[2]]: ",miner_block_countHASH[mintData[2]]);
       // console.log("Epochs Mined totalZKBTC_Mined_HASH[mintData[2]]: ",totalZKBTC_Mined_HASH[mintData[2]]);

        miner_block_count[mintData[2]]
        }catch(err){
            console.log('err: ',err);
        }
    //  console.log("EpochMined: ",epochsMined);
     // console.log("Previous Total Epochs = ",previousEpochCount );

      if(mintData[3] == -1){




      
      if (miner_block_count[mintData[2]] === undefined) {
        miner_block_count[mintData[2]] =  epochsMined;
        if(miner_block_count2[mintData[2]]  === undefined &&  mintData[3] != 0) {
          miner_block_count2[mintData[2]] =  1;
        }else if(  mintData[3] != 0 ){
          miner_block_count2[mintData[2]] +=  1;
        }
      } else {
        miner_block_count[mintData[2]]+=  epochsMined;
        if(miner_block_count2[mintData[2]]  === undefined &&  mintData[3] != 0) {
          miner_block_count2[mintData[2]] =  1;
        }else if(  mintData[3] != 0 ){
          miner_block_count2[mintData[2]] +=  1;
        }
      }
      if(mintData[3] !=0){
        total_tx_count+=1;
      }

      if (total_block_count == 0) {
        total_block_count =  epochsMined;
      } else {
        total_block_count+=  epochsMined;
      }







        console.log("mint data3 = -1");
         totalZKBTC_Mined_HASH[mintData[2]]

          if(mintData[3] !=0 && mintData[0] > last_difficulty_start_block){
      
        if ( total_mint_count_HASH[mintData[2]] ===  undefined) {
          total_mint_count_HASH[mintData[2]] =  1;
        } else {
          total_mint_count_HASH[mintData[2]] +=  1;
        }
        total_TOTAL_mint_count_HASH+=epochsMined;

        // It should be:
        if (totalZKBTC_Mined_HASH[mintData[2]] === undefined) {
            totalZKBTC_Mined_HASH[mintData[2]] = epochsMined;
        } else {
            totalZKBTC_Mined_HASH[mintData[2]] += epochsMined;
        }


        //totalZKBTC_Mined_HASH[mintData[2]] += epochsMined;
      }
      

   //   console.log("Last diff start block: ",last_difficulty_start_block, "    Vs mintDataBlock: ",mintData[0])
      
    }else{

   //   console.log("Last diff start block: ",last_difficulty_start_block, "    Vs mintDataBlock: ",mintData[0])
      if(mintData[3] !=0 && mintData[0] > last_difficulty_start_block){
        if (miner_block_countHASH[mintData[2]] === undefined) {
          miner_block_countHASH[mintData[2]] = mintData[3];
        } else {
          miner_block_countHASH[mintData[2]]+= mintData[3];
        }
        if ( total_mint_count_HASH[mintData[2]] ===  undefined) {
          total_mint_count_HASH[mintData[2]] =  1;
        } else {
          total_mint_count_HASH[mintData[2]] +=  1;
        }
        total_TOTAL_mint_count_HASH+=epochsMined;

        // It should be:
        if (totalZKBTC_Mined_HASH[mintData[2]] === undefined) {
            totalZKBTC_Mined_HASH[mintData[2]] = epochsMined;
        } else {
            totalZKBTC_Mined_HASH[mintData[2]] += epochsMined;
        }


        //totalZKBTC_Mined_HASH[mintData[2]] += epochsMined;
      }
      
      if (miner_block_count[mintData[2]] === undefined) {
        miner_block_count[mintData[2]] =  epochsMined;
        if(miner_block_count2[mintData[2]]  === undefined &&  mintData[3] != 0) {
          miner_block_count2[mintData[2]] =  1;
        }else if(  mintData[3] != 0 ){
          miner_block_count2[mintData[2]] +=  1;
        }
      } else {
        miner_block_count[mintData[2]]+=  epochsMined;
        if(miner_block_count2[mintData[2]]  === undefined &&  mintData[3] != 0) {
          miner_block_count2[mintData[2]] =  1;
        }else if(  mintData[3] != 0 ){
          miner_block_count2[mintData[2]] +=  1;
        }
      }
      if(mintData[3] !=0){
        total_tx_count+=1;
      }

      if (total_block_count == 0) {
        total_block_count =  epochsMined;
      } else {
        total_block_count+=  epochsMined;
      }

      if (totalZKBTC_Mined[mintData[2]] === undefined) {
        totalZKBTC_Mined[mintData[2]] = mintData[3];
        totalZKTC_Calculated += mintData[3];
      } else {
        totalZKBTC_Mined[mintData[2]]+=  mintData[3];
        totalZKTC_Calculated += mintData[3];
      }
              } 
              
     //   console.log(" totalZKBTC_Mined_HASH[mintData[2]]: ", totalZKBTC_Mined_HASH[mintData[2]]);
         //     console.log("Epochs Mined miner_block_count[mintData[2]]: ",  miner_block_count[mintData[2]]);

		//console.log("miner_block_count[miner_address]",miner_block_count[mintData[2]], " vs epochsMined",epochsMined)

    
    });

  } catch (err) {
    console.log('error reading from localStorage:', err.message);
    last_imported_mint_block = 0;
    mined_blocks.length = 0;
  }
  
  var start_log_search_at = Math.max(ethblockstart +1, last_imported_mint_block + 1);
    last_reward_eth_block = last_reward_eth_block - 2

  console.log("searching lastlast_difficulty_start_block", last_difficulty_start_block, "blocks");
  console.log("searching last_imported_mint_block", last_imported_mint_block, "blocks");
  console.log("searching start_log_search_at", start_log_search_at, "blocks");
  console.log("searching last_reward_eth_block", last_reward_eth_block, "blocks");
  console.log("searching last", last_reward_eth_block - start_log_search_at, "blocks"); 
  var blocks_to_search = (current_eth_block - start_log_search_at)
  console.log('blocks to search', blocks_to_search);
  if(blocks_to_search < 1){
    console.log("Only 1 block or less to search abandoning");
    return;
  }
  var stop_log_search_at_loop = 0
  var start_log_search_at_loop = start_log_search_at;
  var iterations = Math.ceil((blocks_to_search / 500));
  if (iterations <= 0) {
    iterations = 1
  }
 var firstRun = 1;
  console.log('do', iterations, 'runs');
  var run = 0
  var attempts = 0

let lastProcessedEpochCount = 0; // Track this from your actual processed transactions

previousEpochCount = maxMinedBlocksEpoch;
    console.log("Epoch Count before Log call",previousEpochCount);
  while (run < iterations) {
    console.log('run', run + 1);
    if(run +1 == iterations){
        console.log("Last run call EpochCount");
    }
    start_log_search_at_loop = start_log_search_at + (run * 500)
    run++;
    stop_log_search_at_loop = start_log_search_at_loop + 499
    if(stop_log_search_at_loop >current_eth_block ){
        console.log("Search too long trimmed");
        stop_log_search_at_loop = current_eth_block;
    }
    console.log('searching from block', start_log_search_at_loop, 'to block', stop_log_search_at_loop);
    if(attempts > 25){
      console.log("Errored too many attempts at block");
      return;
    }
     await sleep(400* attempts);
    //
  /* get all mint() transactions in the last N blocks */
  /* more info: https://github.com/ethjs/ethjs/blob/master/docs/user-guide.md#ethgetlogs */
  /* and https://ethereum.stackexchange.com/questions/12950/what-are-event-topics/12951#12951 */
  await provider.getLogs({
    fromBlock: start_log_search_at_loop,
    toBlock: stop_log_search_at_loop,
    address: ProofOfWorkAddresss,
    topics: [_MINT_TOPIC],
  })
  .then((result) => {
if (run > 0) {
    console.log("Starting new run, previousEpochCount was:", previousEpochCount);
    // You might need to recalculate or verify previousEpochCount here
}
    console.log("got filter results:", result.length, "transactions");
   // total_block_count += result.length;
// Output the result
	  attempts = 0
      
    result.forEach(function(transaction, index){

//var epochsMined = 1; // Add this at the start of forEach
      var tx_hash = transaction['transactionHash'];
      var block_number = parseInt(transaction['blockNumber'].toString());
      var miner_address = getMinerAddressFromTopic(transaction['topics'][1].toString());
      var data3345345 = transaction['data'];
	//console.log("DATA32423, ", data3345345.substring(2, 66));
	var dataAmt = parseInt(data3345345.substring(2, 66), 16) / (10.0 ** 18);
	
      // epochCount (next 64 chars)
      var epochCount = parseInt(data3345345.substring(66, 130), 16);
 
    var epochsMined = epochCount; // Default value
    
    // Look ahead to the next transaction (index + 1)
      if (index === 0) {
        // First transaction in this batch
        if (previousEpochCount !== null && previousEpochCount !== undefined) {
            epochsMined = epochCount - previousEpochCount;
        } else {
            // Very first transaction ever
            epochsMined = epochCount;
        }
    } else {
        // Not the first transaction, use previous transaction in this batch
        var prevTransaction = result[index - 1];
        var prevData = prevTransaction['data'];
        var prevEpochCount = parseInt(prevData.substring(66, 130), 16);
        epochsMined = epochCount - prevEpochCount;
    }
    var savePrevoiusCount = previousEpochCount;
     // console.log("epochsMined: ",epochsMined);
      // Update previous epoch count for next iteration
      previousEpochCount = epochCount;
      lastProcessedEpochCount += epochsMined;
//console.log("DATAAMT: ", dataAmt);
      // log('tx_hash=', tx_hash);
      // log('  block=', block_number);
      // log('  miner=', miner_address)
		
	var Challengerz = data3345345.substring(130, 194);
		if(previousChallenge != Challengerz){
			var previousChallenge2 = previousChallenge;
			console.log("Old challenge: ", previousChallenge, " new challenge: ", Challengerz);
			previousChallenge = Challengerz;
			if(previousChallenge2 !== undefined && previousChallenge2 !== null){
			
						var newBlock = [
    mined_blocks[0] && mined_blocks[0][0] !== undefined ? mined_blocks[0][0] + 1 : block_number+1,
							tx_hash,
							miner_address,
							-1,
                            previousEpochCount
						];
					
					mined_blocks.unshift(newBlock);
			}
			
		}
        
		//one shift to define a challenge change then another for the actual amount mined after the chal change
      mined_blocks.unshift([block_number, tx_hash, miner_address, dataAmt, previousEpochCount])
		
		if(dataAmt !=0 && block_number > last_difficulty_start_block ){
			
			 total_TOTAL_mint_count_HASH+=epochsMined;
			 if(miner_block_countHASH[miner_address] === undefined) {
				miner_block_countHASH[miner_address] = dataAmt;
			  } else {
				  	//console.log("Before : ",miner_address ," CountHash: ",miner_block_countHASH[miner_address]," adding ", dataAmt);
				  	
				miner_block_countHASH[miner_address] += dataAmt;
				  	//console.log("after: ",miner_address ," CountHash: ",miner_block_countHASH[miner_address]);
			  }
			
			if ( total_mint_count_HASH[miner_address] ===  undefined) {
			  total_mint_count_HASH[miner_address] =  1;

			} else {
			  total_mint_count_HASH[miner_address]+=  1;

			}

                    // It should be:
        if (totalZKBTC_Mined_HASH[miner_address] === undefined) {
            totalZKBTC_Mined_HASH[miner_address] = epochsMined;
        } else {
            totalZKBTC_Mined_HASH[miner_address] += epochsMined;
        }

//console.log("totalZKBTC_Mined_HASH[miner_address]",totalZKBTC_Mined_HASH[miner_address], " vs epochsMined",epochsMined)
        
			
		}else if (dataAmt == 0 && block_number > last_difficulty_start_block){


                if (totalZKBTC_Mined_HASH[miner_address] === undefined) {
                    totalZKBTC_Mined_HASH[miner_address] = epochsMined;
                } else {
                    totalZKBTC_Mined_HASH[miner_address] += epochsMined;
                }
console.log("miner_block_count[miner_address]",miner_block_count[miner_address], " vs epochsMined",epochsMined)
        
        }
		//console.log("miner_block_count[miner_address]",miner_block_count[miner_address], " vs epochsMined",epochsMined)
        

        
      if(miner_block_count[miner_address] === undefined) {
        miner_block_count[miner_address] = epochsMined;
	if(dataAmt !=0){
     		miner_block_count2[miner_address] = 1;
	}else{
     		miner_block_count2[miner_address] = 0;
	}
	totalZKBTC_Mined[miner_address] = dataAmt;
	totalZKTC_Calculated += dataAmt;
      } else {
        miner_block_count[miner_address] += epochsMined;
	if(dataAmt !=0){
        	miner_block_count2[miner_address] += 1;
	}
	totalZKBTC_Mined[miner_address] += dataAmt;
	totalZKTC_Calculated += dataAmt;
      }
        
	if(dataAmt !=0){
		total_tx_count+=1;
		total_block_count+=   epochsMined;
	}


      if(epochCount!=miner_block_count[miner_address]){
     // console.log("epoch Count Special: ",epochCount, " =!= miner_block_count[miner_address]: ", miner_block_count[miner_address], " also savePrevoiusCount: ",savePrevoiusCount, " = epochsMined: ",epochsMined);
      }else{ 
     //   console.log("epoch Count: ",epochCount, " vs savePrevoiusCount: ",savePrevoiusCount, " = epochsMined: ",epochsMined);
     

      }
    });
	
  
	
	})  
.catch((error) => {
    console.log('error filtering txs:', error);
     console.log('error filtering txs:', error);
     console.log('repeat run', run);
     run = run - 1
	 // if(attempts > 19){
	//	  run = run +1
	//  }
	  attempts = attempts + 1;
  });
  
  }
  console.log("lastProcessedEpochCount: ",lastProcessedEpochCount );

  console.log("RUn = ", run);
  console.log("RUn = ", mined_blocks[0]);
  console.log("RUn = ", mined_blocks);
    if (run > 0) {
      localStorage.setItem('mintData_EraBitcoin2_afbRAFFABC_B0x1', JSON.stringify(mined_blocks));
      localStorage.setItem('mintData_GreekWedding2_B0x1', JSON.stringify(previousChallenge));
		if (mined_blocks[0] !== undefined) {
      console.log("RUNWorked");
      console.log("Setting Currentethblock to it: ",current_eth_block);
			localStorage.setItem('lastMintBlock_EraBitcoin2_afbRAFFABC_B0x1', current_eth_block);
		}
      localStorage.setItem('lastDifficultyStartBlock_EraBitcoin2_afbRAFFABC_B0x1', last_difficulty_start_block.toString());
    }

    console.log("processed blocks:",
      Object.keys(miner_block_count).length,
      "unique miners");
	var gotthis ={};
	//console.log("miner_block_count123: ",miner_block_count);
// Get the addresses as an array
const addresses = Object.keys(miner_block_count);
var combinedAddresses = await fetchTransactionsData(addresses);
	//console.log("miner_block_count123 addresses: ",addresses);
	//console.log("My Addresses: ", combinedAddresses);

// Call the function with your tettttt array
//combineKnownMiners(tettttt);
// Logging the result
console.log("Combined Known Miners: ", combinedAddresses);
	// Assuming miner_block_count, miner_block_count2, and totalZKBTC_Mined are all initialized properly

	
	// Assuming combinedAddresses is an array of objects
for (var m1 = 0; m1 < combinedAddresses.length; m1++) {
    const addressData1 = combinedAddresses[m1].address;
 
	//	console.log("fsdfsdfsdf: ",combinedAddresses[m1].address);
	//	console.log("address 1 known miner: ",known_miners[combinedAddresses[m1].address]);
    // Skip if m1 is not a known miner
    if (known_miners[combinedAddresses[m1].address] === undefined) continue; 

    for (var m2 = m1; m2 < combinedAddresses.length; m2++) {
        if (m1 === m2) continue; // Skip self-comparison
		
		//console.log("address 2222 known miner: ",known_miners[combinedAddresses[m2].address]);
		
        const addressData2 = combinedAddresses[m2].address;
		//console.log("addysss : ",addressData2);
        // Skip if m2 is not a known miner
        if (known_miners[combinedAddresses[m2].address] === undefined) continue; 
//console.log("address 1 known miner: ",known_miners[combinedAddresses[m1].address]);
	//	console.log("address 2 known miner: ",known_miners[combinedAddresses[m2].address]);
//console.log("address 1 known miner00000: ",known_miners[combinedAddresses[m1].address][0]);
	//	console.log("address 2 known miner0000: ",known_miners[combinedAddresses[m2].address][0]);
        // Check if the miners are in the same group
        if (known_miners[combinedAddresses[m1].address][0] === known_miners[combinedAddresses[m2].address][0]) {
            // Combine values
			console.log("known miner match");
            combinedAddresses[m2].totalValue += combinedAddresses[m1].totalValue; // Sum totalValue
            combinedAddresses[m2].totalCost += combinedAddresses[m1].totalCost; // Sum totalValue
            combinedAddresses[m2].transactionCount += combinedAddresses[m1].transactionCount; // Sum totalValue

		console.log("combining  : ",addressData1, addressData2);
            // Reset m2's values to indicate it's been combined
            combinedAddresses[m1].totalValue = 0
            combinedAddresses[m1].totalCost = 0
            combinedAddresses[m1].transactionCount = 0
		 }
    }
}

// Optionally, filter out the combined entries (where totalCost is 0)
combinedAddresses = combinedAddresses.filter(addressData => addressData.totalCost > 0);

// Logging the result
console.log("Combined Addresses: ", combinedAddresses);
	
	
    /* collapse miner_block_count using known_miners who have multiple
       address into a single address */
    for(var m1 in miner_block_count) {
      for(var m2 in miner_block_count) {
        if(m1 === m2) {
          continue;
        }
        if(known_miners[m1] !== undefined
           && known_miners[m2] !== undefined
           && known_miners[m1][0] == known_miners[m2][0]) {
          miner_block_count[m1] += miner_block_count[m2];
          miner_block_count2[m1] += miner_block_count2[m2];
          miner_block_count[m2] = 0;
          miner_block_count2[m2] = 0;
          totalZKBTC_Mined[m1] += totalZKBTC_Mined[m2];
          totalZKBTC_Mined[m2] = 0;
        }
      }
    }

    /* delete miners with zero blocks (due to collapse op above) */
    Object.keys(miner_block_count).forEach((miner_addr) => {
      if(miner_block_count[miner_addr] == 0) {
        delete miner_block_count[miner_addr]
      }
    });
	
	console.log("processed Recent miner blocks:",
      Object.keys(miner_block_countHASH).length,
      "unique miners");

    /* collapse miner_block_count using known_miners who have multiple
       address into a single address */
    for(var m1 in miner_block_countHASH) {
      for(var m2 in miner_block_countHASH) {
        if(m1 === m2) {
          continue;
        }
        if(known_miners[m1] !== undefined
           && known_miners[m2] !== undefined
           && known_miners[m1][0] == known_miners[m2][0]) {
          miner_block_countHASH[m1] += miner_block_countHASH[m2];
			total_mint_count_HASH[m1] += total_mint_count_HASH[m2];
			total_mint_count_HASH[m2]=0;
          miner_block_countHASH[m2] = 0;
        }
      }
    }

    /* delete miners with zero blocks (due to collapse op above) */
    Object.keys(miner_block_countHASH).forEach((miner_addr) => {
      if(miner_block_countHASH[miner_addr] == 0) {
        delete miner_block_countHASH[miner_addr]
      }
    });
    /* delete miners with zero blocks (due to collapse op above) */
    Object.keys(total_mint_count_HASH).forEach((miner_addr) => {
      if(total_mint_count_HASH[miner_addr] == 0) {
        delete total_mint_count_HASH[miner_addr]
      }
    });
	
	
	
	
	
	
	
	/* delete miners with zero blocks (due to collapse op above) */
    Object.keys(miner_block_count2).forEach((miner_addr) => {
      if(miner_block_count2[miner_addr] == 0) {
        delete miner_block_count2[miner_addr]
      }
    });
	
	/* delete miners with zero blocks (due to collapse op above) */
    Object.keys(miner_block_count2).forEach((miner_addr) => {
      if(miner_block_count2[miner_addr] == 0) {
        delete miner_block_count2[miner_addr]
      }
    });
    /* delete miners with zero blocks (due to collapse op above) */
    Object.keys(totalZKBTC_Mined).forEach((miner_addr) => {
      if(totalZKBTC_Mined[miner_addr] == 0) {
        delete totalZKBTC_Mined[miner_addr]
      }
    });

    /* create sorted list of RECENT miners */
    sorted_miner_block_count_recent_hash = []
    for(var m in miner_block_countHASH) {
        console.log("m: ",m, " totalZKBTC_Mined_HASH",totalZKBTC_Mined_HASH[m]);
        console.log("m: ",m, "  miner_block_countHASH[m]", miner_block_countHASH[m]);
      sorted_miner_block_count_recent_hash.push([m, totalZKBTC_Mined_HASH[m], miner_block_countHASH[m], total_mint_count_HASH[m]]);
    }
    /* descending */
    // Updated JavaScript to match the existing HTML structure with styled CSS classes

sorted_miner_block_count_recent_hash.sort((a, b) => {return b[1] - a[1];});

console.log('done sorting Recent miner info');

var totalBlockszzz = 0;
var a_formattedNumberfffff2 = 0;
var totalblockz = 0;

/* fill in miner info */
var piechart_labels2 = [];
var piechart_dataset2 = {
  data: [],
  backgroundColor: [],
  label: 'miner-data2'
};

// Updated innerHTML generation for recent mining stats - no thead/tbody since your CSS expects direct table content
var innerhtml_buffer2 = '<tr><th style="font-size: 3em;">Miner</th><th>Recent Epochs Minted Count</th>'
  + '<th>% of Minted</th><th>Recent Miner Hashrate</th><th>Transaction Count</th><th>Recent B0x Mined By User</th></tr>';

sorted_miner_block_count_recent_hash.forEach(function(miner_info) {
  var addr = miner_info[0];
  var blocks = miner_info[1];
  var RewardAmount = miner_info[2].toFixed(0);
  var TotalBlocksPerReward = miner_info[3].toFixed(0);
  
  var miner_name_link = getMinerNameLinkHTML(addr, known_miners);
  var percent_of_total_blocks = blocks/total_TOTAL_mint_count_HASH;
  var test = getMinerColor(addr, known_miners);
  
  piechart_dataset2.data.push(blocks);
  piechart_dataset2.backgroundColor.push(test);
  piechart_labels2.push(getMinerName(addr, known_miners));
  
  totalBlockszzz += parseFloat(TotalBlocksPerReward);
  totalblockz += parseFloat(blocks);
  a_formattedNumberfffff2 += parseFloat(RewardAmount);
  
  const formattedNumberfffff2 = new Intl.NumberFormat(navigator.language).format(RewardAmount);
  
  // Generate styled HTML for each miner row
  var minerColorClass = getMinerColor(addr, known_miners);
  var minerName = getMinerName(addr, known_miners);
  
  innerhtml_buffer2 += '<tr class="miner-row"><td class="miner-col">'
    + '<span class="miner-indicator ' + minerColorClass + '"></span>'
    + '<span class="miner-name">' + miner_name_link + '</span>'
    + '</td><td class="stat-value">'
    + blocks + '</td><td class="stat-value">'
    + (100*percent_of_total_blocks).toFixed(2) + '%' + '</td><td class="stat-secondary" style="white-space: nowrap;">'
    +  convertHashRateToReadable2(percent_of_total_blocks*estimated_network_hashrate) + '</td><td class="stat-value">'
    + TotalBlocksPerReward + '</td><td class="stat-value">' + formattedNumberfffff2 + ' B0x</td></tr>';
});

const formattedNumberfffff2FFFF = new Intl.NumberFormat(navigator.language).format(a_formattedNumberfffff2);

// Add totals row with proper styling
innerhtml_buffer2 += '<tr class="miner-row"><td style="border-bottom: 0rem;">TOTAL:'
  + '</td><td class="stat-value" style="border-bottom: 0rem;">'
  + totalblockz + '</td><td class="stat-value" style="border-bottom: 0rem;">'
  + '100%' + '</td><td class="stat-secondary" style="border-bottom: 0rem;">'
  +  convertHashRateToReadable2(estimated_network_hashrate) + '</td><td class="stat-value" style="border-bottom: 0rem;">'
  + totalBlockszzz + '</td><td class="stat-value" style="border-bottom: 0rem;">'
  + formattedNumberfffff2FFFF + ' B0x</td></tr>';

document.querySelector('#row-miners2').style.display = 'block';
document.querySelector('#minerstats2').style.display = 'block';
document.querySelector('#minerstats2').innerHTML = innerhtml_buffer2;

console.log('done populating RECENT miner stats');
showBlockDistributionPieChart2(piechart_dataset2, piechart_labels2);

/* create sorted list of ALL MINTS of miners */
sorted_miner_block_count = []
for(var m in miner_block_count) {
  sorted_miner_block_count.push([m, miner_block_count[m], totalZKBTC_Mined[m], miner_block_count2[m]]);
}
sorted_miner_block_count.sort((a, b) => {return b[1] - a[1];});

console.log('done sorting miner info');

/* fill in miner info */
var piechart_labels = [];
var piechart_dataset = {
  data: [],
  backgroundColor: [],
  label: 'miner-data'
};

var totalSpentINUSD = 0;

// Updated innerHTML generation for all-time mining stats
var innerhtml_buffer = '<tr><th style="font-size: 3em;">Miner</th><th>Total Epochs Minted Count</th>'
  + '<th>% of Minted</th><th>Transaction Count</th><th>TOTAL B0x Mined</th></tr>';

sorted_miner_block_count.forEach(function(miner_info) {
  var addr = miner_info[0];
  
  // Find the matching address in combinedAddresses
  const matchingAddressData = combinedAddresses.find(addressData => addressData.address === addr);
  var totalCostForUser = 0;
  if (matchingAddressData) {
    const totalCost = matchingAddressData.totalCost;
    totalCostForUser = totalCost / 1e18;
  }
  
  var total_WETH_USD_Price = 0.01;
  totalCostForUser = totalCostForUser * total_WETH_USD_Price;
  totalSpentINUSD += totalCostForUser;
  
  var blocks = miner_info[1];
  var RewardAmount = miner_info[2].toFixed(0);
  var TotalBlocksPerReward = miner_info[3].toFixed(0);
  var miner_name_link = getMinerNameLinkHTML(addr, known_miners);
  var percent_of_total_blocks = blocks/total_block_count;
  
  piechart_dataset.data.push(blocks);
  piechart_dataset.backgroundColor.push(getMinerColor(addr, known_miners));
  piechart_labels.push(getMinerName(addr, known_miners));

  const formattedNumberfffff2 = new Intl.NumberFormat(navigator.language).format(RewardAmount);
  
  // Generate styled HTML for each miner row
  var minerColorClass = getMinerColor(addr, known_miners);
  var minerName = getMinerName(addr, known_miners);
  
  innerhtml_buffer += '<tr class="miner-row"><td class="miner-col">'
    + '<span class="miner-indicator ' + minerColorClass + '"></span>'
    + '<span class="miner-name">' + miner_name_link + '</span>'
    + '</td><td class="stat-value">'
    + blocks + '</td><td class="stat-value">'
    + (100*percent_of_total_blocks).toFixed(2) + '%' + '</td><td class="stat-value">'
    + TotalBlocksPerReward + '</td><td class="stat-value" style="white-space: nowrap">'
    + formattedNumberfffff2 + ' B0x</td></tr>';
});

const formattedNumberfffff23 = new Intl.NumberFormat(navigator.language).format(totalZKTC_Calculated.toFixed(0));

document.querySelector('.SuccessfulMintTransactions').innerHTML = "<b> "+(total_tx_count).toLocaleString()+" </b> txs";

/* add the last row (totals) with proper styling */
innerhtml_buffer += '<tr class="miner-row"><td style="border-bottom: 0rem;">TOTAL:</td><td class="stat-value" style="border-bottom: 0rem;">'
  + total_block_count + '</td><td class="stat-value" style="border-bottom: 0rem;">100%</td><td class="stat-value" style="border-bottom: 0rem;">'
  + total_tx_count + '</td><td class="stat-value" style="border-bottom: 0rem;">'
  + formattedNumberfffff23 + ' B0x</td></tr>';

document.querySelector('#minerstats').innerHTML = innerhtml_buffer;
document.querySelector('#row-miners').style.display = 'block';

console.log('done populating miner stats');
showBlockDistributionPieChart(piechart_dataset, piechart_labels);

var blocks_since_last_reward = current_eth_block - last_reward_eth_block;
var date_now = new Date();
var date_of_last_mint = new Date(date_now.getTime() - blocks_since_last_reward*_SECONDS_PER_ETH_BLOCK*1000)

function get_date_from_eth_block(eth_block) {
  const options = { year: 'numeric', month: 'numeric', day: 'numeric', hour: 'numeric', minute: 'numeric', hour12: true, milliseconds: false };
  return new Date(date_of_last_mint.getTime() - ((last_reward_eth_block - eth_block)*_SECONDS_PER_ETH_BLOCK*1000)).toLocaleString('en-US', options);
}

var totalzkBTCMinted = 0.0;
var previousBlock = 0;
var index = 0;
var dt = new Date();

// Updated innerHTML generation for blocks table
var innerhtml_buffer = '<tr><th>Time (Approx)</th><th>zkSync Era Block #</th>'
  + '<th>Transaction Hash</th><th style="width: 200px;">Miner</th><th>Reward Amount</th></tr>';

mined_blocks.forEach(function(block_info) {
  var eth_block = parseInt(block_info[0]);
  var tx_hash = block_info[1];
  var addr = block_info[2];
  var dataF = block_info[3].toFixed(4);
  var epochCnt = block_info[4];
  
  // Get the next block's epoch count
  var nextEpochCnt = null;
  if (index + 1 < mined_blocks.length) {
    nextEpochCnt = mined_blocks[index + 1][4];
  }
  
  if (index === 0) {
    epchCount = EpochCountBeforeCall - epochCnt;
  } else if (nextEpochCnt !== null) {
    epchCount = epochCnt - nextEpochCnt;
  } 
  index = index + 1;

  const formattedNumberfffff = new Intl.NumberFormat(navigator.language).format(dataF);
  var miner_name_link = getMinerNameLinkHTML(addr, known_miners);
  var minerName = getMinerName(addr, known_miners);

  var transaction_url = _BLOCK_EXPLORER_TX_URL + tx_hash;
  var block_url = _BLOCK_EXPLORER_BLOCK_URL + eth_block;

  totalzkBTCMinted += parseFloat(epchCount);

  if(formattedNumberfffff == -1) {
    var parzedint = parseInt(totalzkBTCMinted);
    totalzkBTCMinted = 0.0;
    if(parzedint > 2016) {
      // parzedint = 2016;
    }

    const formattedNumberparzedint = new Intl.NumberFormat(navigator.language).format(parzedint);
    var finalstr = "";
    const searchString = "PeriodNumberperiod";
    str = innerhtml_buffer;
    const lastIndex = str.lastIndexOf(searchString);
    if (lastIndex === -1) {
      finalstr = str;
    } else {
      const before = str.substring(0, lastIndex);
      const after = str.substring(lastIndex + searchString.length);
      finalstr = before + formattedNumberparzedint + after;
    }
    innerhtml_buffer = finalstr;

    if(eth_block > 25990908) {
      innerhtml_buffer += '<tr><td align="right" style="text-overflow:ellipsis;white-space: nowrap;overflow: hidden;">'
        + get_date_from_eth_block(eth_block) + '</td><td>'
        + '<b>New difficulty period</b>' + '</td><td>'
        + '<b>New Challenge</b>'
        + '</td><td><b> Previous Period had</b></td><td class="stat-value"><b>PeriodNumberperiod Mints</b></td></tr>';
      totalzkBTCMinted = 0.0;
    } else {
      innerhtml_buffer += '<tr><td align="right" style="text-overflow:ellipsis;white-space: nowrap;overflow: hidden;">'
        + get_date_from_eth_block(eth_block) + '</td><td>'
        + '<b>New difficulty period</b>' + '</td><td>'
        + '<b>New Challenge</b>'
        + '</td><td><b> Previous Period had</b></td><td class="stat-value"><b>0 Mints</b></td></tr>';
      totalzkBTCMinted = 0.0;
    }
  } else {
    // Generate styled HTML for blocks with proper CSS classes
    innerhtml_buffer += '<tr><td align="right" style="width: 200px;">'
      + get_date_from_eth_block(eth_block) + '</td><td class="hash">'
      + '<a href="' + block_url + '" target="_blank">' + eth_block + '</a></td><td class="hash">'
      + '<a href="' + transaction_url + '" title="' + tx_hash + '" target="_blank">'
      + tx_hash.substr(0, 16) + '...</a></td><td align="right" style="text-overflow:ellipsis;white-space: nowrap;overflow: hidden;">'
      + '<span class="miner-cell">' + miner_name_link + '</span></td><td class="stat-value">'
      + formattedNumberfffff + " B0x</td></tr>";
  }
});

document.querySelector('#row-blocks').style.display = 'block';
document.querySelector('#blockstats').style.display = 'block';
document.querySelector('#blockstats').innerHTML = innerhtml_buffer;

console.log('done populating block stats');



}

































            var providerTempStats = "";
            var signerTempStats =  "";

async function connectTempRPCforStats(){
   // Create provider from the existing eth instance

   providerTempStats = new ethers.providers.JsonRpcProvider("https://base-sepolia.g.alchemy.com/v2/fTukefKxyH-72aDTEBUHqcad2_SK53CC");
   
            // Create a random wallet and connect to provider
            const randomWallet = ethers.Wallet.createRandom();
            signerTempStats = randomWallet.connect(providerTempStats);
}


var lastBaseBlock=0;
var currentBlock=0;
var estHashrate=0;
var lastDifficultyStartBlock=0;
  
async function GetContractStats(){
    if(!walletConnected){
       await connectTempRPCforStats();
    }
    var provids = provider;
    if(!walletConnected){
        provids=providerTempStats;
    }
    console.log("Connect done");


        console.log("Connect done");

    // Alchemy recommends concurrent requests, so let's use them!
    // Group into logical batches under 50 requests each
    
    // Batch 1: Core mining stats (6 calls)
    const [price, Era, EpochCount, nextDiff, target, diff] = await Promise.all([
        getCurrentPrice(provids),
        getRewardEra(provids),
        getEpochCount(provids),
        getNextDifficulty(provids),
        getTarget(provids),
        getDifficulty(provids)
    ]);
    
    // Batch 2: Timing & reward stats (6 calls)  
    const [avgRewardTimeTotals, blocksToGo, timeEmergency, lastDiffStartBlock, lastDiffStartTime, lastBaseBlock2] = await Promise.all([
        getAvgRewardTime(provids),
        getBlocksToReadjust(provids),
        getTimeEmergency(provids),
        getLastDiffStartBlock(provids),
        getLastDiffStartime(provids),
        getLastBaseBlock(provids)
    ]);
lastBaseBlock=lastBaseBlock2;
    
    // Batch 3: Supply & social stats (5 calls)
    const [totalDistributedMining, maxperEra, TokenHolders, Transfers, TotalOperations] = await Promise.all([
        getTokensMinted(provids),
        getMaxSupplyForEra(provids),
        getTokenHolders(provids),
        getTransfers(provids),
        getTotalOperations(provids)
    ]);

    
  /*  var price =  await getCurrentPrice(provids);
    var Era =  await getRewardEra(provids);
    var EpochCount =  await getEpochCount(provids);
    var nextDiff =  await getNextDifficulty(provids);
    var target =  await getTarget(provids);
    var diff = await  getDifficulty(provids);

*/



   // var avgRewardTimeTotals =  await getAvgRewardTime(provids);
    
    var avgRewardTime = avgRewardTimeTotals.TimePerEpoch;

// Convert back to number before passing to getTimeUnits
    var avgTime = await getTimeUnits(parseInt(avgRewardTime));

    console.log("AvgRewardTime: ", avgRewardTime.toString());

    var avgReardTime1 = avgTime.avgTime;
    var avgReardTimeUnits = avgTime.units;

    var currentRewardPerSolve = avgRewardTimeTotals.RewardsAtTime;


    var rewardPerSolve = currentRewardPerSolve/1e18;


   // var blocksToGo =  await getBlocksToReadjust(provids);

  //  var timeEmergency =  await getTimeEmergency(provids);
    var timeEmergencyBreakdown = await getTimeUnits(timeEmergency);
    var timeEmergencyTime = timeEmergencyBreakdown.avgTime;
    var timeEmergencyTimeUnits = timeEmergencyBreakdown.units;

   // var lastDiffStartBlock=  await getLastDiffStartBlock(provids);
    lastDifficultyStartBlock = lastDiffStartBlock;
  //  var lastDiffStartTime=  await getLastDiffStartime(provids);
  //  var totalDistributedMining = await getTokensMinted(provids);
//
  //  var maxperEra = await getMaxSupplyForEra(provids);
    var remainingSupplyINERA=  await getRemainingSupplyINERA(provids, totalDistributedMining, maxperEra);
    var avgBlocksRemainingInEra=  await getRemainingBlocksInEra(rewardPerSolve,  totalDistributedMining, maxperEra);
  //  var TokenHolders=  await getTokenHolders(provids);
 //   var Transfers=  await getTransfers(provids);
 //   var TotalOperations= await  getTotalOperations(provids);
    lastBaseBlock=  await getLastBaseBlock(provids);
    currentBlock = lastBaseBlock;
    var nextEraInfo = await getDaysUntilNextEra(provids);
    var daysUntilNextEra = nextEraInfo.daysUntil;
    var mintSpeedUntilNextEra = nextEraInfo.MintSpeed;

    var mintSpeed = await getTimeUnits(mintSpeedUntilNextEra);
    var mintSpeedNextEraTime = mintSpeed.avgTime;
    var mintSpeedUnits = mintSpeed.units;
    console.log("TIME LEFT: blocksToGo: ",blocksToGo);
    console.log("TIME LEFT: avgTime: ",avgTime);
    var timeLeftBeforeAdjustment = parseFloat(blocksToGo) *parseInt(avgRewardTime)  ;
    console.log("TIME LEFT : ",timeLeftBeforeAdjustment);
    var timeBeforeAdjustz = await getTimeUnits(timeLeftBeforeAdjustment);
    timeBeforeAdjust =timeBeforeAdjustz.avgTime;
    timeBeforeAdjustUnits =timeBeforeAdjustz.units;


    var hashrate = await getHashrate(diff,avgRewardTime);
    estHashrate=hashrate;
    var hashrateFormatted = convertHashRateToReadable(hashrate);
    var hashrateunit = hashrateFormatted.units;
    var hashRates = hashrateFormatted.value;


    var timeBeforenewEra = await getTimeUnits(avgRewardTime*avgBlocksRemainingInEra);
    timeBeforeEra= timeBeforenewEra.avgTime;
    timeBeforeEraUnits = timeBeforenewEra.units;
    var timestampLastDiffStart = await getTimestampFromBlock(lastDiffStartBlock, provids);


    // Update the HTML elements with the retrieved values
    document.querySelector('.stat-value-price').innerHTML = `${price} <span class="unit">$</span>`;
    document.querySelector('.stat-value-currentEra').innerHTML = `${Era} <span class="detail">/ 55 (next era: ${timeBeforeEra} ${timeBeforeEraUnits} @ ${avgReardTime1} ${avgReardTimeUnits} per block)</span>`;
    document.querySelector('.stat-value-epochCount').textContent = EpochCount;
    document.querySelector('.stat-value-difficulty').innerHTML = `${diff} <span class="detail">(next: ${nextDiff})</span>`;
    document.querySelector('.stat-value-hashrate').innerHTML = `${hashRates} <span class="detail eestHashRateUnit">${hashrateunit}</span>`;
    document.querySelector('.stat-value-averageRewardTime').innerHTML = `${avgReardTime1} <span class="detail avgRewardUnit">${avgReardTimeUnits}</span>`;
    document.querySelector('.stat-value-rewardPerSolve').innerHTML = `${rewardPerSolve} <span class="detail rewardPerSolveUnit">B0x per solve</span>`;
    document.querySelector('.stat-value-blocksToGo').innerHTML = `${blocksToGo} <span class="detail blocksToGoUnit">(~${timeBeforeAdjust} ${timeBeforeAdjustUnits})</span>`;
    document.querySelector('.stat-value-emergency').innerHTML = `${timeEmergencyTime} <span class="detail emergencyUnit">${timeEmergencyTimeUnits}</span>`;
    document.querySelector('.stat-value-lastDiffBlock').innerHTML = `${lastDiffStartBlock} <span class="detail lastDiffBlockDetail">(${timestampLastDiffStart})</span>`;
    document.querySelector('.stat-value-lastDiffTime').innerHTML =`${lastDiffStartTime} <span class="detail lastDiffBlockDetail2">(${timestampLastDiffStart})</span>`;
    document.querySelector('.stat-value-remainingSupply').innerHTML = `${remainingSupplyINERA.toLocaleString()} <span class="unit">B0x <span class="detail">(~${avgBlocksRemainingInEra} blocks or ~${timeBeforeEra} ${timeBeforeEraUnits} @ ${avgReardTime1} ${avgReardTimeUnits} per block)</span></span>`;
    document.querySelector('.stat-value-tokenHolders').innerHTML = `${TokenHolders.toLocaleString()} <span class="unit">holders</span>`;
    document.querySelector('.stat-value-tokenTransfers').innerHTML = `${Transfers.toLocaleString()} <span class="unit">transfers</span>`;
    document.querySelector('.stat-value-contractOps').innerHTML = `${TotalOperations.toLocaleString()} <span class="unit">txs</span>`;
    document.querySelector('.stat-value-lastBaseBlock').textContent = lastBaseBlock;

document.querySelector('.stat-value-distMining').innerHTML = `${parseFloat(totalDistributedMining).toLocaleString()}  <span class="unit">B0x</span></span>`;
document.querySelector('.stat-value-MAxSupply').innerHTML = `${parseFloat(maxperEra).toLocaleString()}  <span class="unit">B0x</span></span>`;

        // Initial calculation
        calculateMining();
}




            var providerTempStats = "";
            var signerTempStats =  "";

async function connectTempRPCforStats(){
   // Create provider from the existing eth instance

   providerTempStats = new ethers.providers.JsonRpcProvider("https://base-sepolia.g.alchemy.com/v2/fTukefKxyH-72aDTEBUHqcad2_SK53CC");
   
            // Create a random wallet and connect to provider
            const randomWallet = ethers.Wallet.createRandom();
            signerTempStats = randomWallet.connect(providerTempStats);
}



async function useCurrentDiff(){

    if(!walletConnected){
       await connectTempRPCforStats();
    }
    var provids = provider;
    if(!walletConnected){
        provids=providerTempStats;
    }
    console.log("Connect done");


        console.log("Connect done");

    var diffzzfzfz = await getDifficulty(provids);



            calculateMining();

}

let provider = ""
async function useNextDiff(){
    if(!walletConnected){
       await connectTempRPCforStats();
    }
    var provids = provider;
    if(!walletConnected){
        provids=providerTempStats;
    }
    console.log("Connect done");


        console.log("Connect done");

    var diffzzfzfz = await getNextDifficulty(provids);



            calculateMining();

}


// Constants
      
        // Constants from the formula
        const POW_2_22 = Math.pow(2, 22); // 4,194,304
        const SECONDS_PER_DAY = 86400;
        const MIN_REWARD = 6.25; // tokens per block
        const MAX_REWARD = 25; // tokens per block

        // Sample difficulty values for demo
        const CURRENT_DIFFICULTY = 0.24995304;
        const NEXT_DIFFICULTY = 0.28234567;

        // Get DOM elements
        const hashrateInput = document.getElementById('hashrate-input');
        const hashrateUnit = document.getElementById('hashrate-unit');
        const difficultyInput = document.getElementById('difficulty-input');
        const currentDiffBtn = document.getElementById('current-diff-btn');
        const nextDiffBtn = document.getElementById('next-diff-btn');

        // Result elements
        const avgBlockTimeEl = document.getElementById('avg-block-time');
        const realisticBlockTimeEl = document.getElementById('realistic-block-time');
        const maxTokensEl = document.getElementById('max-tokens');

        // Calculate mining results based on the formula in HTML
        function calculateMining() {
    // Get input values
    const hashrate = parseFloat(hashrateInput.value) || 0;
    const unitMultiplier = parseFloat(hashrateUnit.value) || 1;
    console.log("unit Multiplier = ", unitMultiplier);
    const difficulty = parseFloat(difficultyInput.value) || 0.00000001; // Avoid division by zero
    
    // Convert hashrate to H/s
    const hashrateHps = hashrate * unitMultiplier;
    
    if (hashrateHps <= 0) {
        // Reset display if no valid hashrate
        avgBlockTimeEl.textContent = 'âˆž';
        realisticBlockTimeEl.textContent = 'âˆž';
        minTokensEl.textContent = '0.00';
        maxTokensEl.textContent = '0.00';
        return;
    }

    // Calculate average time to solve a block (in seconds)
    // Formula from HTML: time = (2^22 Ã— difficulty) / hashrate
    const avgBlockTime = (POW_2_22 * difficulty) / hashrateHps;
    
    // Calculate time for 10 blocks (more realistic estimate)
    const realistic10BlockTime = avgBlockTime * 10;
    
    // Calculate blocks per day
    const blocksPerDay = SECONDS_PER_DAY / avgBlockTime;

    var blocksPerDay2= SECONDS_PER_DAY / 600;

    
    // Calculate rewards based on block time rules:
    // Fast blocks (< 10 min): reward = 25 Ã— (block_time / 600)
    // Slow blocks (â‰¥ 10 min): reward = 25 tokens
    let rewardPerBlock;
    if (avgBlockTime >= 600) {
        // Slow blocks: â‰¥10 minutes = fixed 25 tokens
        rewardPerBlock = 25;

    } else {
        // Fast blocks: reward inversely proportional to speed
        rewardPerBlock = 25 * (avgBlockTime / 600);
        if(rewardPerBlock<6.25){
            rewardPerBlock=6.25;
        }
        
    }
    
    // Calculate tokens per day
    // Since reward is now calculated based on block time, min = max
    const tokensPerDayMax = blocksPerDay * rewardPerBlock;
    // Since reward is now calculated based on block time, min = max
    const tokensPerDayMax2 = blocksPerDay2 * rewardPerBlock;
    

        if(avgBlockTime<600){


    maxTokensEl.textContent = tokensPerDayMax.toFixed(2);
    }else{

    maxTokensEl.textContent = tokensPerDayMax2.toFixed(2);
        
    }

    // Update the UI with calculated values
    avgBlockTimeEl.textContent = formatTime(avgBlockTime);
    realisticBlockTimeEl.textContent = formatTime(realistic10BlockTime);
    
    // Update additional display elements if they exist
    if (document.getElementById('display-hashrate')) {
        document.getElementById('display-hashrate').textContent = hashrateHps.toLocaleString();
    }
    if (document.getElementById('display-difficulty')) {
        document.getElementById('display-difficulty').textContent = difficulty.toFixed(8);
    }
}

        // Format time display
        function formatTime(seconds) {
            if (seconds < 1) {
                return (seconds * 1000).toFixed(1) + 'ms';
            } else if (seconds < 60) {
                return seconds.toFixed(1);
            } else if (seconds < 3600) {
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = (seconds % 60).toFixed(1);
                return `${minutes}m ${remainingSeconds}s`;
            } else if (seconds < 86400) {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                return `${hours}h ${minutes}m`;
            } else {
                const days = Math.floor(seconds / 86400);
                const hours = Math.floor((seconds % 86400) / 3600);
                return `${days}d ${hours}h`;
            }
        }

        // Use current difficulty
        function useCurrentDiff() {
            difficultyInput.value = CURRENT_DIFFICULTY;
            calculateMining();
        }

        // Use next difficulty
        function useNextDiff() {
            difficultyInput.value = NEXT_DIFFICULTY;
            calculateMining();
        }

        // Event Listeners
        hashrateInput.addEventListener('input', calculateMining);
        hashrateUnit.addEventListener('change', calculateMining);
        difficultyInput.addEventListener('input', calculateMining);
        currentDiffBtn.addEventListener('click', useCurrentDiff);
        nextDiffBtn.addEventListener('click', useNextDiff);

        // Initial calculation
        calculateMining();


/*

        <div class="stat-row">
                        <span class="stat-label2">Price of 1 B ZERO X in USD</span>
                        <span class="stat-value2 stat-value-price">NaN <span class="unit">$</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Current Reward Era</span>
                        <span class="stat-value2 stat-value-currentEra">0 <span class="detail">/ 39 (next era: ~8.1 days @ 3.6 seconds a mint)</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Epoch Count</span>
                        <span class="stat-value2 stat-value-epochCount">4030</span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Mining Difficulty</span>
                        <span class="stat-value2 stat-value-difficulty">0.250 <span class="detail">(next: ~1.000)</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Mining Target</span>
                        <span class="stat-value2">2.1058608453327367e+65</span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Estimated Hashrate</span>
                        <span class="stat-value2 stat-value-hashrate">292.47 <span class="eestHashRateUnit">Kh/s</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Current Average Reward Time</span>
                        <span class="stat-value2 stat-value-averageRewardTime">0.060 <span class="avgRewardUnit">minutes</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Reward per Solve</span>
                        <span class="stat-value2 stat-value-rewardPerSolve">25 <span class="rewardPerSolveUnit">B0x per solve</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Rewards Until Readjustment</span>
                        <span class="stat-value2 stat-value-blocksToGo">2 <span class="blocksToGoUnit">(~7.2 seconds)</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Time Until Emergency Adjustment Activated if all rewards not solved</span>
                        <span class="stat-value2 stat-value-emergency">13.9 <span class="emergencyUnit">days</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Last Difficulty Start Block</span>
                        <span class="stat-value2 stat-value-lastDiffBlock">30230154 <span class="lastDiffBlockDetail">(08-26-2025 12:16:36)</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Last Difficulty Time</span>
                        <span class="stat-value2 stat-value-lastDiffTime">1756228596</span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Target Time</span>
                        <span class="stat-value2">10 <span class="unit">minutes</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Mined Supply Remaining in Era</span>
                        <span class="stat-value2 stat-value-remainingSupply">4,888,693 <span class="unit">B0x <span class="detail">(~195548 blocks)</span></span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Tokens distributed via Mining</span>
                        <span class="stat-value2 stat-value-distMining">10,861,306 <span class="unit">B0x</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Max Mined Supply for Current Era</span>
                        <span class="stat-value2 stat-value-MAxSupply">15,750,000 <span class="unit">B0x</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Token Holders</span>
                        <span class="stat-value2 stat-value-tokenHolders">128 <span class="unit">holders</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Token Transfers</span>
                        <span class="stat-value2 stat-value-tokenTransfers">10,720 <span class="unit">transfers</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Total Contract Operations</span>
                        <span class="stat-value2 stat-value-contractOps">10,481 <span class="unit">txs</span></span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Last Base Block Number</span>
                        <span class="stat-value2 stat-value-lastBaseBlock">30233764</span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label2">Total Supply</span>
                        <span class="stat-value2 stat-value-AbsoluteMaxSupply">31,165,100 <span class="unit">B0x</span></span>
                    </div>
                </div>

                        <button class="btn-secondary" onclick="GetContractStats()">GetContractStats</button>
*/






    </script>


    </body></html>
